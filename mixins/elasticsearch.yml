---
# Depends on:
#   - common.yml

actions:
  setupES:
    - getVaultData
    - runESCircleCIPipeline:
        workflow: terraform_apply
    - createESAccountAndAliases
    - setESEndpointInJcustomerConfig

  runESCircleCIPipeline:
    # Parameters:
    # - workflow : the pipeline workflow to run (terraform_apply/terraform_destroy)
    - vaultSecretReadKeyB64:
        secretPath: paas/envs-common/cloud-ec-infra-circleci-api
        secretKey: token
    - set:
        circleCiToken: ${globals.vaultSecretData}

    - if ("${globals.papiToken.print()}" == ""):
        getPapiInfoAll

    - cmd [${nodes.cp.first.id}]: |-
        export PAPI_TOKEN="${globals.papiToken}"
        export PAPI_HOSTNAME="${globals.papiHostname}"
        export PAPI_ENV_ID="${globals.papiEnvId}"
        export PAPI_API_VERSION="${globals.papiApiVersion}"

        sleep 60 # Required in case the cron get_metadata_from_HN hasn't run yet
        source /metadata_from_HOST
        if [ -z $JEL_ENV_ROLE ]; then
          echo "JEL_ENV_ROLE variable is not defined in /metadata_from_HOST"
          exit 1
        fi

        environment=$(papi.py -X GET "paas-environment/$PAPI_ENV_ID")
        ec_deployment_id=$(echo $environment | jq -r .ec_deployment_id)
        ec_deployment=$(papi.py -X GET "ec-deployment/$ec_deployment_id")

        if [ -z "$environment" ] || [ -z "$ec_deployment" ]; then
          echo "Failed to fetch environment or ec_deployment"
          exit 1
        fi

        organization_id=$(echo $environment | jq -r .paas_organization_id)
        ec_deployment_id=$(echo $ec_deployment | jq -r .ec_deployment_id)
        ec_deployment_name=$(echo $ec_deployment | jq -r .name)

        CCToken=$(echo -n ${this.circleCiToken} | base64 -d)
        response=$(curl -fLSs -XPOST https://circleci.com/api/v2/project/github/Jahia/cloud-ec-infra/pipeline -H "Circle-Token: $CCToken" --header 'content-type: application/json' --data \
        "{
           \"parameters\": {
               \"workflow\": \"${this.workflow}\",
               \"env\": \"$JEL_ENV_ROLE\",
               \"papi_organization_id\": $organization_id,
               \"papi_instance_id\": $ec_deployment_id,
               \"papi_instance_name\": \"$ec_deployment_name\"
             }
         }")
        if [ $? -ne 0 ]; then
          echo "Pipeline trigger failed: $response"
          exit 1
        fi

        pipelineId=$(echo $response | jq -r .id)
        timeout=600 # 10 minutes
        sleep_interval=10
        workflow_status="running"
        while [ "$workflow_status" = "running" ]; do
          sleep $sleep_interval
          response=$(curl -fLSs "https://circleci.com/api/v2/pipeline/$pipelineId/workflow" -H "Circle-Token: $CCToken")
          if [ $? -eq 0 ]; then
            new_workflow_status=$(echo $response | jq -r '.items[0].status')
            if [ "$new_workflow_status" != "null" ]; then
              workflow_status=$new_workflow_status
            fi
          fi
          if [ $timeout -lt 1 ]; then
            echo "Timeout reached while waiting for circleCi pipeline to end"
            exit 1
          fi
          ((timeout-=$sleep_interval))

        done
        if [ "$workflow_status" != "success" ]; then
          echo "Elasticsearch cluster creation failed"
          exit 1
        fi

  createESAccountAndAliases:
    - if ("${globals.papiToken.print()}" == ""):
        getPapiInfoAll

    - cmd [${nodes.cp.first.id}]: |-
        export PAPI_TOKEN="${globals.papiToken}"
        export PAPI_HOSTNAME="${globals.papiHostname}"
        export PAPI_ENV_ID="${globals.papiEnvId}"
        export PAPI_API_VERSION="${globals.papiApiVersion}"

        environment=$(papi.py -X GET "paas-environment/$PAPI_ENV_ID")
        ec_deployment_id=$(echo $environment | jq -r .ec_deployment_id)
        ec_deployment=$(papi.py -X GET "ec-deployment/$ec_deployment_id")

        es_endpoint=$(echo $ec_deployment | jq -r .es_endpoint)
        kibana_endpoint=$(echo $ec_deployment | jq -r .kibana_endpoint)

        creds=$(papi.py -X GET "ec-deployment/$ec_deployment_id/credentials")
        password=$(echo $creds | jq -r .password)
        login=$(echo $creds | jq -r .login)

        # Create Kibana role
        curl -fLSsu "$login:$password" "$kibana_endpoint/api/security/role/${env.envName}" -H 'Content-Type:application/json' -H "kbn-xsrf: reporting" -d '{"metadata": {},"elasticsearch": {"cluster": ["monitor", "manage_index_templates"], "indices": [{"names": ["${env.envName}_jc-*"], "privileges": ["all"]},{"names": ["global-geonameentry"], "privileges": ["view_index_metadata"]}] }, "kibana": [{"base": ["all"], "feature": {}, "spaces": ["${env.envName}"]}]}' -XPUT
        if [ $? -ne 0 ]; then
          echo "Failed to create kibana role." && exit 1
        fi

        # Create ES user
        curl -fLSsu "$login:$password" "$es_endpoint/_security/user/${env.envName}" -XPUT  -d '{"password": "${globals.elasticsearch_password}", "roles": ["${env.envName}"], "full_name": "${env.envName}"}'  -H 'Content-Type:application/json'
        if [ $? -ne 0 ]; then
          echo "Failed to create ES user." && exit 1
        fi

        curl -fLSsu "$login:$password" "$es_endpoint/_cat/indices/global-geonameentry" > /dev/null 2>&1
        if [ $? -ne 0 ]; then
          curl -fLSsu "$login:$password" "$es_endpoint/global-geonameentry" -H 'Content-Type:application/json' -s -XPUT -d '{
            "settings" : {"index" : {"number_of_shards" : 1,"number_of_replicas" : 1}},
            "mappings": {
              "properties": {
                "admin1Code": {
                  "type": "text",
                  "fields": {"keyword": {"type": "keyword","ignore_above": 256}}
                },
                "admin2Code": {
                  "type": "text",
                  "fields": {"keyword": {"type": "keyword","ignore_above": 256}}
                },
                "admin3Code": {
                  "type": "text",
                  "fields": {"keyword": {"type": "keyword","ignore_above": 256}}
                },
                "admin4Code": {
                  "type": "text",
                  "fields": {"keyword": {"type": "keyword","ignore_above": 256}}
                },
                "asciiname": {
                  "type": "text",
                  "fields": {"keyword": {"type": "keyword","ignore_above": 256}}
                },
                "cc2": {
                  "type": "text",
                  "fields": {"keyword": {"type": "keyword","ignore_above": 256}}
                },
                "countryCode": {
                  "type": "text",
                  "fields": {"keyword": {"type": "keyword","ignore_above": 256}}
                },
                "dem": {
                  "type": "text",
                  "fields": {"keyword": {"type": "keyword","ignore_above": 256}}
                },
                "elevation": {"type": "long"},
                "featureClass": {
                  "type": "text",
                  "fields": {"keyword": {"type": "keyword","ignore_above": 256}}
                },
                "featureCode": {
                  "type": "text",
                  "fields": {"keyword": {"type": "keyword","ignore_above": 256}}
                },
                "itemId": {
                  "type": "text",
                  "fields": {"keyword": {"type": "keyword","ignore_above": 256}}
                },
                "itemType": {
                  "type": "text",
                  "fields": {"keyword": {"type": "keyword","ignore_above": 256}}
                },
                "location": {"type": "geo_point"},
                "modificationDate": {"type": "date"},
                "name": {
                  "type": "text",
                  "fields": {"keyword": {"type": "keyword","ignore_above": 256}}
                },
                "population": {"type": "long"},
                "timezone": {
                  "type": "text",
                  "fields": {"keyword": {"type": "keyword","ignore_above": 256}}
                }
              }
            }
          }'

          if [ $? -ne 0 ]; then
            echo "Failed to create global geonameentry index." && exit 1
          fi
        fi

        curl -fLSsu "$login:$password" "$es_endpoint/_aliases" -H 'Content-Type:application/json' -d '{"actions": [{"add": {"is_write_index": true,"index": "global-geonameentry","alias": "${env.envName}_jc-geonameentry"}}]}'
        if [ $? -ne 0 ]; then
          echo "Failed to create geonameentry alias." && exit 1
        fi

  setESEndpointInJcustomerConfig:
    - if ("${globals.papiToken.print()}" == ""):
        getPapiInfoAll
    - cmd [cp]: |-
        export PAPI_TOKEN="${globals.papiToken}"
        export PAPI_HOSTNAME="${globals.papiHostname}"
        export PAPI_ENV_ID="${globals.papiEnvId}"
        export PAPI_API_VERSION="${globals.papiApiVersion}"

        environment=$(papi.py -X GET "paas-environment/$PAPI_ENV_ID")
        ec_deployment_id=$(echo $environment | jq -r .ec_deployment_id)
        ec_deployment=$(papi.py -X GET "ec-deployment/$ec_deployment_id")

        es_endpoint=$(echo $ec_deployment | jq -r .es_endpoint)

        sed -i "s,curl.*9200,curl -u \\\"\${UNOMI_ELASTICSEARCH_USERNAME}:\${UNOMI_ELASTICSEARCH_PASSWORD}\\\" \\\"https://\${UNOMI_ELASTICSEARCH_ADDRESSES}\\\",g" /etc/systemd/system/karaf.service
        systemctl daemon-reload

        es_hostname=$(echo $es_endpoint | sed 's,https\:\/\/,,g')
        echo "$es_hostname"

    - script: |-
        envVars = {
          "UNOMI_ELASTICSEARCH_ADDRESSES": "${response.out}",
        }
        return api.env.control.AddContainerEnvVars("${env.envName}", session, "cp", envVars);

  getECAdminCredentials:
    - if ("${globals.papiToken.print()}" == ""):
        getPapiInfoAll
    - cmd [${nodes.cp.first.id}]: |-
        export PAPI_TOKEN="${globals.papiToken}"
        export PAPI_HOSTNAME="${globals.papiHostname}"
        export PAPI_ENV_ID="${globals.papiEnvId}"
        export PAPI_API_VERSION="${globals.papiApiVersion}"
        environment=$(papi.py -X GET "paas-environment/$PAPI_ENV_ID")
        ec_deployment_id=$(echo $environment | jq -r .ec_deployment_id)
        ec_deployment_credentials=$(papi.py -X GET "ec-deployment/$ec_deployment_id/credentials")
        ec_admin_login=$(echo $ec_deployment_credentials | jq -r .login)
        ec_admin_password=$(echo $ec_deployment_credentials | jq -r .password)
        if [ -z "$ec_admin_login" ] || [ -z "$ec_admin_password" ]; then
          echo "Failed to fetch EC admin credentials"
          exit 1
        fi
        echo $ec_admin_login:$ec_admin_password
    - setGlobals:
        ecAdminCredentials: ${response.out}

  destroyESDeployment:
    - getVaultData
    - vaultSecretReadKeyB64:
        secretPath: paas/envs-common/cloud-ec-infra-circleci-api
        secretKey: token
    - set:
        circleCiToken: ${globals.vaultSecretData}
    - if ("${globals.papiToken.print()}" == ""):
        getPapiInfoAll
    - script: |-
        import org.apache.http.client.methods.HttpGet;
        import org.apache.http.client.methods.HttpPost;
        import org.apache.http.client.methods.HttpPut;
        import org.apache.http.impl.client.HttpClients;
        import org.apache.http.util.EntityUtils;
        import org.apache.http.entity.StringEntity;

        papiToken = "${globals.papiToken}";
        papiEnvId = "${globals.papiEnvId}";
        papiBaseUrl = "https://${globals.papiHostname}/api/${globals.papiApiVersion}/";

        getPaasEnv = new HttpGet(papiBaseUrl + "paas-environment/" + papiEnvId);
        getPaasEnv.setHeader("X-PAPI-KEY", papiToken);
        httpClient = HttpClients.createDefault();
        resp = httpClient.execute(getPaasEnv);
        if (resp.getStatusLine().getStatusCode() != 200) {
          return {"result": 1, errOut: "Can't get paas environment " + papiEnvId};
        }
        paasEnv = JSON.parse(EntityUtils.toString(resp.getEntity()));
        ecDeploymentId = paasEnv["ec_deployment_id"]

        getECDeployment = new HttpGet(papiBaseUrl + "ec-deployment/" + ecDeploymentId);
        getECDeployment.setHeader("X-PAPI-KEY", papiToken);
        httpClient = HttpClients.createDefault();
        resp = httpClient.execute(getECDeployment);
        if (resp.getStatusLine().getStatusCode() != 200) {
          return {"result": 1, errOut: "Can't get ec deployment " + ecDeploymentId + ": " + resp};
        }
        ec_deployment = JSON.parse(EntityUtils.toString(resp.getEntity()));

        if (ec_deployment["mutualized"]) {
          return {"result": 0, "out": "Mutualized EC deployment, nothing to do"}
        }

        updateECDeployment = new HttpPut(papiBaseUrl + "paas-environment/" + papiEnvId);
        updateECDeployment.setHeader("X-PAPI-KEY", papiToken);
        updateECDeployment.setHeader("Content-Type", "application/json");
        json = toJSON({"ec_deployment_id": undefined});
        stringEntity = new StringEntity(json);
        updateECDeployment.setEntity(stringEntity);
        httpClient = HttpClients.createDefault();
        resp = httpClient.execute(updateECDeployment);

        if (resp.getStatusLine().getStatusCode() != 200) {
          return {"result": 1, errOut: "Can't edit paas environment " + papiEnvId  + ": " + resp};
        }

        jel_env_role = jelastic.env.control.GetNodeGroups("${env.envName}", session).object.filter(function (object) {
                                        return object.name == "cp";}).pop().JEL_ENV_ROLE;
        if (!jel_env_role) {
          return {"result": 1, errOut: "Can't get JEL_ENV_ROLE from node group data" };
        }

        circleCiToken="${this.circleCiToken.fromBase64()}"
        triggerPipeline = new HttpPost("https://circleci.com/api/v2/project/github/Jahia/cloud-ec-infra/pipeline");
        triggerPipeline.setHeader("Circle-Token", circleCiToken);
        triggerPipeline.setHeader("Content-Type", "application/json");
        json = toJSON({
          "parameters": {
            "workflow": "terraform_destroy",
            "env": jel_env_role,
            "papi_organization_id": ec_deployment["organization_id"],
            "papi_instance_id": ec_deployment["ec_deployment_id"],
            "papi_instance_name": ec_deployment["name"]
          }
        });
        stringEntity = new StringEntity(json);
        triggerPipeline.setEntity(stringEntity);
        httpClient = HttpClients.createDefault();
        resp = httpClient.execute(triggerPipeline);

        if (resp.getStatusLine().getStatusCode() != 201) {
          return {"result": 1, errOut: "Can't trigger CircleCi Pipleline:" + resp};
        }


        pipelineId = JSON.parse(EntityUtils.toString(resp.getEntity()))["id"];
        timeout=600000 // 10 minutes
        sleep_interval=10000 // 10 sec
        workflow_status="running"
        while (workflow_status == "running" && timeout > 0) {
          java.lang.Thread.sleep(sleep_interval);

          getWorkflow = new HttpGet("https://circleci.com/api/v2/pipeline/" + pipelineId + "/workflow");
          getWorkflow.setHeader("Circle-Token", circleCiToken);
          httpClient = HttpClients.createDefault();
          resp = httpClient.execute(getWorkflow);
          if (resp.getStatusLine().getStatusCode() == 200) {
            result = JSON.parse(EntityUtils.toString(resp.getEntity()));
            if (result["items"][0]["status"])
              workflow_status = result["items"][0]["status"];
          }
          timeout -= sleep_interval
        }
        if (workflow_status != "success")
          return {"result": 1, errOut: "CircleCi Pipleline failed"};

        return {"result": 0};

  setShardAllocation:
    # Parameters;
    #   - allocation: to be set to strings "primaries" or "null"
    #   - target
    - if("${this.allocation}" == "primaries"):
        - set:
            rule: "\"primaries\""
    - elif("${this.allocation}" == "null"):
        - set:
            rule: "null"
    - log: "Set cluster.routing.allocation.enable to ${this.rule}"
    - cmd[${this.target}]: |-
        # If ${this.rule} is "null" then it's possible that ES daemon is not yet
        # started so we wait a bit for it
        # We check if ES daemon is started with a curl instead of `systemctl is-active`
        # because there is a lag between the time the service is considered active
        # and the node is reachable via curl
        if [ "${this.rule}" == "null" ]; then
          maxi=128
          i=1
          until (curl -sf "${HOSTNAME}:9200/_cluster/health?timeout=1s" >/dev/null); do
            if [ $i -gt $maxi ]; then
              echo "Elasticsearch is still not started, aborting..."
              exit 1
            fi
            echo "Waiting for ES to be started $i/$maxi"
            ((i++))
            sleep 2
          done
        fi

        curl -s -H 'Content-Type: application/json' -XPUT \
          -d '{"persistent":{"cluster.routing.allocation.enable": ${this.rule} }}' \
          http://${HOSTNAME}:9200/_cluster/settings

  forceESFlush:
    # Parameters:
    #   - target
    - cmd[${this.target}]: |-
        es_version=$(curl http://${HOSTNAME}:9200/ -s | jq -r .version.number)
        if printf '%s\n%s' '7.6.0' "$es_version" | sort -CV; then
          endpoint="_flush"         # since 7.6.0
        else
          endpoint="_flush/synced"  # deprecated since 7.6.0
        fi

        flush() {
          failed=$(curl -s -XPOST http://${HOSTNAME}:9200/${endpoint} | jq -r .[].failed | awk '{f=f+$1} END{print f}')
          if [ $failed -eq 0 ]; then
            return 0
          else
            return 1
          fi
        }

        # initiate flush and wait a few
        curl -s -XPOST http://${HOSTNAME}:9200/${endpoint}
        sleep 10

        # now check no flush failed
        maxi=66
        i=1
        until flush; do
          if [ $i -gt $maxi ]; then
            echo "ES node still have failure(s) on flush, aborting..."
            exit 1
          fi
          echo "flush iteration $i/$maxi"
          ((i++))
          sleep 2
        done

  checkEsClusterStatus:
    # Every second, we check cluster health. If curl fails with a 10s timeout, then exit 1.
    # For 3-nodes clusters, until status is green & actual nodes number equals nodes.es.length,
    # we check that the number of active shards is increasing (meaning the node is not fully
    # initialized yet). If it is still not after 10s, exit 1.
    # For single node ES, we check green or yellow status
    - cmd[${nodes.es.first.id}]: |-
        health_file="/tmp/es_cluster_health.json"
        i=0
        prev_active_shards=0
        total_nodes_count=${nodes.es.length}
        # Single ES node: we check green or yellow status
        healthcheck_condition='[[ "$status" == "green" ]] || [[ "$status" == "yellow" ]]'

        # 3-nodes cluster: we check green status only
        if [ $total_nodes_count -gt 1 ]; then
          healthcheck_condition='[[ "$status" == "green" ]] && [ $real_nodes_count -eq $total_nodes_count ]'
        fi

        while [ $i -lt 20 ]; do
          curl -Ssf 'es:9200/_cluster/health?timeout=10s' > $health_file || (rm -f $health_file; exit 1)
          status=$(cat $health_file | jq -r '.status')
          real_nodes_count=$(cat $health_file | jq '.number_of_nodes')
          if eval $healthcheck_condition; then
            exit 0
          fi
          active_shards=$(cat $health_file | jq ".active_shards")
          [ $active_shards -eq $prev_active_shards ] && ((i=i+1)) || i=0
          prev_active_shards=$active_shards
          sleep 1
        done
        echo "[ERROR] There is an issue with the cluster, please check" 1>&2
        exit 1
      user: root

  setAwsSnapshotRepository:
    # Parameters:
    #   - repositoryName
    #   - backupName
    #   - region
    #   - account
    #   - logsPath
    #   - awsAccessKeyId
    #   - awsSecretAccessKey
    - cmd[${nodes.cp.first.id}]: |-
        aws_access_key="${this.awsAccessKeyId}"
        aws_secret_key="${this.awsSecretAccessKey}"
        ec_admin_credentials=${globals.ecAdminCredentials}
        curl \
          -H 'Content-Type: application/json' \
          -u $ec_admin_credentials \
          -XPUT "https://$UNOMI_ELASTICSEARCH_ADDRESSES/_snapshot/${this.repositoryName}?verify=false&pretty" \
          -d"{
            \"type\": \"s3\",
            \"settings\": {
                \"bucket\": \"${this.account}\",
                \"region\": \"${this.region}\",
                \"base_path\" : \"${this.backupName}/elasticsearch\",
                \"access_key\": \"$aws_access_key\",
                \"secret_key\": \"$aws_secret_key\"
            }
          }" 2>>${this.logsPath} || exit 1

  setAzureSnapshotRepository:
    # Parameters:
    #   - repositoryName
    #   - backupName
    #   - logsPath
    #   - awsAccessKeyId
    #   - awsSecretAccessKey
    #   - operation
    #   - account
    - getAzureElasticsearchSecret:
        awsAccessKeyId: ${this.awsAccessKeyId}
        awsSecretAccessKey: ${this.awsSecretAccessKey}
        backupName: ${this.backupName}
        operation: "${this.operation}"
        account: ${this.account}
        logsPath: ${this.logsPath}

    - cmd[${nodes.cp.first.id}]: |-
        ec_admin_credentials=${globals.ecAdminCredentials}
        curl \
          -H 'Content-Type: application/json' \
          -u $ec_admin_credentials \
          -XPUT "https://$UNOMI_ELASTICSEARCH_ADDRESSES/_snapshot/${this.repositoryName}?verify=false&pretty" \
          -d"{
            \"type\": \"azure\",
            \"settings\": {
                \"container\": \"${this.backupName}\",
                \"base_path\" : \"elasticsearch\",
                \"account\" : \"${this.account}\",
                \"key\" : \"${globals.azure_secret}\"
            }
          }" 2>>${this.logsPath} || exit 1

  getAzureElasticsearchSecret:
    # Parameters:
    #   - awsAccessKeyId
    #   - awsSecretAccessKey
    #   - backupName
    #   - operation
    #   - account
    #   - logsPath
    # Returns:
    #   ${globals.azure_secret}
    - cmd[${nodes.cp.first.id}]: |-
        export AWS_ACCESS_KEY_ID="${this.awsAccessKeyId}" AWS_SECRET_ACCESS_KEY="${this.awsSecretAccessKey}"
        cd jelastic_backup
        python3 elasticsearch.py --bucketname ${this.account} --backupname ${this.backupName} --cloudprovider=azure --operation=${this.operation} 2>>${this.logsPath} || exit 1
    - cmd[${nodes.cp.first.id}]: |-
        cat /tmp/azurecred
        rm -f /tmp/azurecred
    - setGlobals:
        azure_secret: "${response.out}"
    - if ("${globals.azure_secret}" == ""):
        - return:
            type: error
            message: "An error occurred during backup repository configuration."
