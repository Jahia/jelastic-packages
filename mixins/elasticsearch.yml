---
# Depends on:
#   - common.yml

actions:
  setupES:
    - getVaultData
    - runESCircleCIPipeline:
        workflow: terraform_apply
    - createESAccountAndAliases
    - setESEndpointInJcustomerConfig

  setupES4AS:
    - getVaultData
    - runESCircleCIPipeline:
        workflow: terraform_apply
    - createESAccount4AS

  runESCircleCIPipeline:
    # Parameters:
    # - workflow : the pipeline workflow to run (terraform_apply/terraform_destroy)
    - vaultSecretReadKeyB64:
        secretPath: paas/envs-common/cloud-ec-infra-circleci-api
        secretKey: token
    - set:
        circleCiToken: ${globals.vaultSecretData}

    - if ("${globals.papiToken.print()}" == ""):
        getPapiInfoAll
    - getCloudConf

    - cmd [${nodes.cp.first.id}]: |-
        export PAPI_TOKEN="${globals.papiToken}"
        export PAPI_HOSTNAME="${globals.papiHostname}"
        export PAPI_ENV_ID="${globals.papiEnvId}"
        export PAPI_API_VERSION="${globals.papiApiVersion}"

        source /metadata_from_HOST
        if [ -z $JEL_ENV_ROLE ]; then
          echo "JEL_ENV_ROLE variable is not defined in /metadata_from_HOST"
          exit 1
        fi

        environment=$(papi.py -X GET "paas-environment/$PAPI_ENV_ID")
        ec_deployment_id=$(echo $environment | jq -r .ec_deployment_id)
        ec_deployment=$(papi.py -X GET "ec-deployment/$ec_deployment_id")

        if [ -z "$environment" ] || [ -z "$ec_deployment" ]; then
          echo "Failed to fetch environment or ec_deployment"
          exit 1
        fi

        organization_id=$(echo $environment | jq -r .paas_organization_id)
        ec_deployment_id=$(echo $ec_deployment | jq -r .ec_deployment_id)
        ec_deployment_name=$(echo $ec_deployment | jq -r .name)
        ec_deployment_mutualized=$(echo $ec_deployment | jq -r .mutualized)
        ec_deployment_es_endpoint=$(echo $ec_deployment | jq -r .es_endpoint)

        CCToken=$(echo -n ${this.circleCiToken} | base64 -d)

        generate_payload() {
        if [[ "${globals.cloud_conf.ec.tag}" =~ ^v[0-9]+(\.[0-9]+)*$ ]]; then
          branch_or_tag="tag"
        else
          branch_or_tag="branch"
        fi
        cat << EOF
        {
          "$branch_or_tag": "${globals.cloud_conf.ec.tag}",
          "parameters": {
            "workflow": "${this.workflow}",
            "env": "$JEL_ENV_ROLE",
            "papi_organization_id": $organization_id,
            "papi_instance_id": $ec_deployment_id,
            "papi_instance_name": "$ec_deployment_name"
          }
        }
        EOF
        }

        response=$(curl -fLSs -XPOST https://circleci.com/api/v2/project/github/Jahia/cloud-ec-infra/pipeline \
                        -H "Circle-Token: $CCToken" --header 'content-type: application/json' --data "$(generate_payload)")
        if [ $? -ne 0 ]; then
          echo "Pipeline trigger failed: $response"
          exit 1
        fi

        # Skip the timeout while updating a mutualized EC deployment but wait till end if it's a new EC deployment
        if [ "$ec_deployment_mutualized" = "false" ] || [ "$ec_deployment_es_endpoint" = null ]; then
          pipelineId=$(echo $response | jq -r .id)
          response=$(curl -LSs "https://circleci.com/api/v2/pipeline/$pipelineId/workflow" -H "Circle-Token: $CCToken")
          if [ "$(echo $response | jq -r '.items[0].status')" == "null" ]; then
            echo "No workflow created on CircleCI, aborting. Pipeline ID: $pipelineId. Response: $response" >&2
            exit 1
          fi
          timeout=1200 # 20 minutes
          sleep_interval=20
          workflow_status="running"
          while [ "$workflow_status" = "running" ]; do
            sleep $sleep_interval
            response=$(curl -fLSs "https://circleci.com/api/v2/pipeline/$pipelineId/workflow" -H "Circle-Token: $CCToken")
            if [ $? -eq 0 ]; then
              new_workflow_status=$(echo $response | jq -r '.items[0].status')
              if [ "$new_workflow_status" != "null" ]; then
                workflow_status=$new_workflow_status
              fi
            fi
            if [ $timeout -lt 1 ]; then
              echo "Timeout reached while waiting for circleCi pipeline to end"
              exit 1
            fi
            ((timeout-=$sleep_interval))

          done
          if [ "$workflow_status" != "success" ]; then
            echo "Elasticsearch cluster creation failed"
            exit 1
          fi
        fi

  createESAccount4AS:
    - if ("${globals.papiToken.print()}" == ""):
        getPapiInfoAll

    - cmd [proc]: |-
        export PAPI_TOKEN="${globals.papiToken}"
        export PAPI_HOSTNAME="${globals.papiHostname}"
        export PAPI_ENV_ID="${globals.papiEnvId}"
        export PAPI_API_VERSION="${globals.papiApiVersion}"

        environment=$(papi.py -X GET "paas-environment/$PAPI_ENV_ID")
        ec_deployment_id=$(echo $environment | jq -r .ec_deployment_id)
        ec_deployment=$(papi.py -X GET "ec-deployment/$ec_deployment_id")

        es_endpoint=$(echo $ec_deployment | jq -r .es_endpoint)
        kibana_endpoint=$(echo $ec_deployment | jq -r .kibana_endpoint)

        creds=$(papi.py -X GET "ec-deployment/$ec_deployment_id/credentials")
        password=$(echo $creds | jq -r .password)
        login=$(echo $creds | jq -r .login)

        # Create Kibana role
        curl -fLSsu "$login:$password" "$kibana_endpoint/api/security/role/${env.envName}" -H 'Content-Type:application/json' -H "kbn-xsrf: reporting" -d '{"metadata": {},"elasticsearch": {"cluster": ["monitor", "manage_index_templates", "manage"], "indices": [{"names": ["${env.envName}__as-*"], "privileges": ["all"]}] }, "kibana": [{"base": ["all"], "feature": {}, "spaces": ["${env.envName}"]}]}' -XPUT
        if [ $? -ne 0 ]; then
          echo "Failed to create kibana role." && exit 1
        fi

        # Create ES user
        curl -fLSsu "$login:$password" "$es_endpoint/_security/user/${env.envName}" -XPUT  -d '{"password": "${globals.elasticsearch_password}", "roles": ["${env.envName}"], "full_name": "${env.envName}"}'  -H 'Content-Type:application/json'
        if [ $? -ne 0 ]; then
          echo "Failed to create ES user." && exit 1
        fi

  createESAccountAndAliases:
    - if ("${globals.papiToken.print()}" == ""):
        getPapiInfoAll

    - cmd [${nodes.cp.first.id}]: |-
        export PAPI_TOKEN="${globals.papiToken}"
        export PAPI_HOSTNAME="${globals.papiHostname}"
        export PAPI_ENV_ID="${globals.papiEnvId}"
        export PAPI_API_VERSION="${globals.papiApiVersion}"

        environment=$(papi.py -X GET "paas-environment/$PAPI_ENV_ID")
        ec_deployment_id=$(echo $environment | jq -r .ec_deployment_id)
        ec_deployment=$(papi.py -X GET "ec-deployment/$ec_deployment_id")

        es_endpoint=$(echo $ec_deployment | jq -r .es_endpoint)
        kibana_endpoint=$(echo $ec_deployment | jq -r .kibana_endpoint)

        creds=$(papi.py -X GET "ec-deployment/$ec_deployment_id/credentials")
        password=$(echo $creds | jq -r .password)
        login=$(echo $creds | jq -r .login)

        # Create Kibana role
        curl -fLSsu "$login:$password" "$kibana_endpoint/api/security/role/${env.envName}" -H 'Content-Type:application/json' -H "kbn-xsrf: reporting" -d '{"metadata": {},"elasticsearch": {"cluster": ["monitor", "manage_index_templates"], "indices": [{"names": ["${env.envName}__jc-*"], "privileges": ["all"]},{"names": ["global-geonameentry"], "privileges": ["view_index_metadata"]}] }, "kibana": [{"base": ["all"], "feature": {}, "spaces": ["${env.envName}"]}]}' -XPUT
        if [ $? -ne 0 ]; then
          echo "Failed to create kibana role." && exit 1
        fi

        # Create ES user
        curl -fLSsu "$login:$password" "$es_endpoint/_security/user/${env.envName}" -XPUT  -d '{"password": "${globals.elasticsearch_password}", "roles": ["${env.envName}"], "full_name": "${env.envName}"}'  -H 'Content-Type:application/json'
        if [ $? -ne 0 ]; then
          echo "Failed to create ES user." && exit 1
        fi

        curl -fLSsu "$login:$password" "$es_endpoint/_cat/indices/global-geonameentry" > /dev/null 2>&1
        if [ $? -ne 0 ]; then
          curl -fLSsu "$login:$password" "$es_endpoint/global-geonameentry" -H 'Content-Type:application/json' -s -XPUT -d '{
            "settings" : {"index" : {"number_of_shards" : 1,"number_of_replicas" : 1}},
            "mappings": {
              "properties": {
                "admin1Code": {
                  "type": "text",
                  "fields": {"keyword": {"type": "keyword","ignore_above": 256}}
                },
                "admin2Code": {
                  "type": "text",
                  "fields": {"keyword": {"type": "keyword","ignore_above": 256}}
                },
                "admin3Code": {
                  "type": "text",
                  "fields": {"keyword": {"type": "keyword","ignore_above": 256}}
                },
                "admin4Code": {
                  "type": "text",
                  "fields": {"keyword": {"type": "keyword","ignore_above": 256}}
                },
                "asciiname": {
                  "type": "text",
                  "fields": {"keyword": {"type": "keyword","ignore_above": 256}}
                },
                "cc2": {
                  "type": "text",
                  "fields": {"keyword": {"type": "keyword","ignore_above": 256}}
                },
                "countryCode": {
                  "type": "text",
                  "fields": {"keyword": {"type": "keyword","ignore_above": 256}}
                },
                "dem": {
                  "type": "text",
                  "fields": {"keyword": {"type": "keyword","ignore_above": 256}}
                },
                "elevation": {"type": "long"},
                "featureClass": {
                  "type": "text",
                  "fields": {"keyword": {"type": "keyword","ignore_above": 256}}
                },
                "featureCode": {
                  "type": "text",
                  "fields": {"keyword": {"type": "keyword","ignore_above": 256}}
                },
                "itemId": {
                  "type": "text",
                  "fields": {"keyword": {"type": "keyword","ignore_above": 256}}
                },
                "itemType": {
                  "type": "text",
                  "fields": {"keyword": {"type": "keyword","ignore_above": 256}}
                },
                "location": {"type": "geo_point"},
                "modificationDate": {"type": "date"},
                "name": {
                  "type": "text",
                  "fields": {"keyword": {"type": "keyword","ignore_above": 256}}
                },
                "population": {"type": "long"},
                "timezone": {
                  "type": "text",
                  "fields": {"keyword": {"type": "keyword","ignore_above": 256}}
                }
              }
            }
          }'

          if [ $? -ne 0 ]; then
            echo "Failed to create global geonameentry index." && exit 1
          fi
        fi

        curl -fLSsu "$login:$password" "$es_endpoint/_aliases" -H 'Content-Type:application/json' -d '{"actions": [{"add": {"is_write_index": true,"index": "global-geonameentry","alias": "${env.envName}__jc-geonameentry"}}]}'
        if [ $? -ne 0 ]; then
          echo "Failed to create geonameentry alias." && exit 1
        fi

  setESEndpointInJcustomerConfig:
    - if ("${globals.papiToken.print()}" == ""):
        getPapiInfoAll
    - cmd [cp]: |-
        export PAPI_TOKEN="${globals.papiToken}"
        export PAPI_HOSTNAME="${globals.papiHostname}"
        export PAPI_ENV_ID="${globals.papiEnvId}"
        export PAPI_API_VERSION="${globals.papiApiVersion}"

        environment=$(papi.py -X GET "paas-environment/$PAPI_ENV_ID")
        ec_deployment_id=$(echo $environment | jq -r .ec_deployment_id)
        ec_deployment=$(papi.py -X GET "ec-deployment/$ec_deployment_id")

        es_endpoint=$(echo $ec_deployment | jq -r .es_endpoint)

        sed -i "s,curl.*9200,curl -u \\\"\${UNOMI_ELASTICSEARCH_USERNAME}:\${UNOMI_ELASTICSEARCH_PASSWORD}\\\" \\\"https://\${UNOMI_ELASTICSEARCH_ADDRESSES}\\\",g" /etc/systemd/system/karaf.service
        systemctl daemon-reload

        es_hostname=$(echo $es_endpoint | sed 's,https\:\/\/,,g')
        echo "$es_hostname"

    - script: |-
        envVars = {
          "UNOMI_ELASTICSEARCH_ADDRESSES": "${response.out}",
        }
        return api.env.control.AddContainerEnvVars("${env.envName}", session, "cp", envVars);

  getECAdminCredentials:
    - if ("${globals.papiToken.print()}" == ""):
        getPapiInfoAll
    - cmd [${nodes.cp.first.id}]: |-
        export PAPI_TOKEN="${globals.papiToken}"
        export PAPI_HOSTNAME="${globals.papiHostname}"
        export PAPI_ENV_ID="${globals.papiEnvId}"
        export PAPI_API_VERSION="${globals.papiApiVersion}"
        environment=$(papi.py -X GET "paas-environment/$PAPI_ENV_ID")
        ec_deployment_id=$(echo $environment | jq -r .ec_deployment_id)
        ec_deployment_credentials=$(papi.py -X GET "ec-deployment/$ec_deployment_id/credentials")
        ec_admin_login=$(echo $ec_deployment_credentials | jq -r .login)
        ec_admin_password=$(echo $ec_deployment_credentials | jq -r .password)
        if [ -z "$ec_admin_login" ] || [ -z "$ec_admin_password" ]; then
          echo "Failed to fetch EC admin credentials"
          exit 1
        fi
        echo $ec_admin_login:$ec_admin_password
    - setGlobals:
        ecAdminCredentials: ${response.out}

  destroyESDeployment:
    - getVaultData
    - vaultSecretReadKeyB64:
        secretPath: paas/envs-common/cloud-ec-infra-circleci-api
        secretKey: token
    - set:
        circleCiToken: ${globals.vaultSecretData}
    - if ("${globals.papiToken.print()}" == ""):
        getPapiInfoAll
    - script: |-
        import org.apache.http.client.methods.HttpGet;
        import org.apache.http.client.methods.HttpPost;
        import org.apache.http.client.methods.HttpPut;
        import org.apache.http.client.methods.HttpDelete;
        import org.apache.http.impl.client.HttpClients;
        import org.apache.http.util.EntityUtils;
        import org.apache.http.entity.StringEntity;
        import java.util.Base64;

        papiToken = "${globals.papiToken}";
        papiEnvId = "${globals.papiEnvId}";
        papiBaseUrl = "https://${globals.papiHostname}/api/${globals.papiApiVersion}/";

        getPaasEnv = new HttpGet(papiBaseUrl + "paas-environment/" + papiEnvId);
        getPaasEnv.setHeader("X-PAPI-KEY", papiToken);
        httpClient = HttpClients.createDefault();
        resp = httpClient.execute(getPaasEnv);
        if (resp.getStatusLine().getStatusCode() != 200) {
          return {"result": 1, errOut: "Can't get paas environment " + papiEnvId};
        }
        paasEnv = JSON.parse(EntityUtils.toString(resp.getEntity()));
        ecDeploymentId = paasEnv["ec_deployment_id"]

        getECDeployment = new HttpGet(papiBaseUrl + "ec-deployment/" + ecDeploymentId);
        getECDeployment.setHeader("X-PAPI-KEY", papiToken);
        httpClient = HttpClients.createDefault();
        resp = httpClient.execute(getECDeployment);
        if (resp.getStatusLine().getStatusCode() != 200) {
          return {"result": 1, errOut: "Can't get ec deployment " + ecDeploymentId + ": " + resp};
        }
        ec_deployment = JSON.parse(EntityUtils.toString(resp.getEntity()));

        // If the deleted env is one of many mutualized envs, we don't delete the EC deployment.
        // Instead, we clean up indices and geonameentry alias related to the env.
        if (ec_deployment["mutualized"] && ec_deployment["paas_environments"].length > 1) {
            // Get ES credentials from PAPI
            getECDeploymentCreds = new HttpGet(papiBaseUrl + "ec-deployment/" + ecDeploymentId + "/credentials");
            getECDeploymentCreds.setHeader("X-PAPI-KEY", papiToken);
            httpClient = HttpClients.createDefault();
            resp = httpClient.execute(getECDeploymentCreds);
            if (resp.getStatusLine().getStatusCode() != 200) {
              return {"result": 1, errOut: "Can't get ec deployment credentials for " + ecDeploymentId + ": " + resp};
            }
            es_credentials = JSON.parse(EntityUtils.toString(resp.getEntity()));
            auth_basic_es_credentials = es_credentials["login"] + ":" + es_credentials["password"]
            creds_bytes = (new java.lang.String(auth_basic_es_credentials)).getBytes("UTF-8");
            encoded_auth_basic_creds = Base64.getEncoder().encodeToString(creds_bytes);

            // Delete indices
            deleteESIndices = new HttpDelete(ec_deployment["es_endpoint"] + "/${env.shortdomain}__jc-*");
            deleteESIndices.setHeader("Authorization", "Basic " + encoded_auth_basic_creds);
            httpClient = HttpClients.createDefault();
            resp = httpClient.execute(deleteESIndices);
            if (resp.getStatusLine().getStatusCode() != 200) {
              return {"result": 1, errOut: "Can't delete indices:" + resp};
            }

            // Delete geonameentry alias
            deleteGeonameAlias = new HttpDelete(ec_deployment["es_endpoint"] + "/global-geonameentry/_alias/${env.shortdomain}__jc-geonameentry");
            deleteGeonameAlias.setHeader("Authorization", "Basic " + encoded_auth_basic_creds);
            httpClient = HttpClients.createDefault();
            resp = httpClient.execute(deleteGeonameAlias);
            if (resp.getStatusLine().getStatusCode() != 200) {
              return {"result": 1, errOut: "Can't delete geonameentry alias:" + resp};
            }

            return {"result": 0, "out": "indices and geonameentry alias deleted"};
        }

        updateECDeployment = new HttpPut(papiBaseUrl + "paas-environment/" + papiEnvId);
        updateECDeployment.setHeader("X-PAPI-KEY", papiToken);
        updateECDeployment.setHeader("Content-Type", "application/json");
        json = toJSON({"ec_deployment_id": undefined});
        stringEntity = new StringEntity(json);
        updateECDeployment.setEntity(stringEntity);
        httpClient = HttpClients.createDefault();
        resp = httpClient.execute(updateECDeployment);

        if (resp.getStatusLine().getStatusCode() != 200) {
          return {"result": 1, errOut: "Can't edit paas environment " + papiEnvId  + ": " + resp};
        }

        jel_env_role = jelastic.env.control.GetNodeGroups("${env.envName}", session).object.filter(function (object) {
                                        return object.name == "cp";}).pop().JEL_ENV_ROLE;
        if (!jel_env_role) {
          return {"result": 1, errOut: "Can't get JEL_ENV_ROLE from node group data" };
        }

        circleCiToken="${this.circleCiToken.fromBase64()}"
        triggerPipeline = new HttpPost("https://circleci.com/api/v2/project/github/Jahia/cloud-ec-infra/pipeline");
        triggerPipeline.setHeader("Circle-Token", circleCiToken);
        triggerPipeline.setHeader("Content-Type", "application/json");
        cloud_conf = jelastic.env.control.getnodegroups('${env.envName}', session).object.filter(function (object) {
                                                        return object.name == "cp"}).pop().cloud_conf
        regex = /^v[0-9]+(\.[0-9]+)*$/
        if (cloud_conf.ec.tag.match(regex)) {
          branch_or_tag = "tag"
        } else {
          branch_or_tag = "branch"
        }
        json = {
          "parameters": {
            "workflow": "terraform_destroy",
            "env": jel_env_role,
            "papi_organization_id": ec_deployment["organization_id"],
            "papi_instance_id": ec_deployment["ec_deployment_id"],
            "papi_instance_name": ec_deployment["name"]
          }
        };
        json[branch_or_tag] = cloud_conf.ec.tag
        json = toJSON(json)
        stringEntity = new StringEntity(json);
        triggerPipeline.setEntity(stringEntity);
        httpClient = HttpClients.createDefault();
        resp = httpClient.execute(triggerPipeline);

        if (resp.getStatusLine().getStatusCode() != 201) {
          return {"result": 1, errOut: "Can't trigger CircleCi Pipleline:" + resp};
        }


        pipelineId = JSON.parse(EntityUtils.toString(resp.getEntity()))["id"];
        timeout=600000 // 10 minutes
        sleep_interval=10000 // 10 sec
        workflow_status="running"
        while (workflow_status == "running" && timeout > 0) {
          java.lang.Thread.sleep(sleep_interval);

          getWorkflow = new HttpGet("https://circleci.com/api/v2/pipeline/" + pipelineId + "/workflow");
          getWorkflow.setHeader("Circle-Token", circleCiToken);
          httpClient = HttpClients.createDefault();
          resp = httpClient.execute(getWorkflow);
          if (resp.getStatusLine().getStatusCode() == 200) {
            result = JSON.parse(EntityUtils.toString(resp.getEntity()));
            if (result["items"][0]["status"])
              workflow_status = result["items"][0]["status"];
          }
          timeout -= sleep_interval
        }
        if (workflow_status != "success")
          return {"result": 1, errOut: "CircleCi Pipleline failed"};

        return {"result": 0, "out": "EC deployment deleted"};

  getElasticCloudDeploymentId:
    # Returns:
    #   ${globals.elasticCloudDeploymentId}
    - if ("${globals.papiToken.print()}" == ""):
        getPapiInfoAll
    - cmd[${nodes.cp.first.id}]: |-
        export PAPI_TOKEN="${globals.papiToken}"
        export PAPI_HOSTNAME="${globals.papiHostname}"
        export PAPI_ENV_ID="${globals.papiEnvId}"
        export PAPI_API_VERSION="${globals.papiApiVersion}"
        environment=$(papi.py -X GET paas-environment/$PAPI_ENV_ID) || exit 1
        ec_deployment_id=$(echo $environment | jq -r .ec_deployment_id) || exit 1
        ec_deployment=$(papi.py -X GET ec-deployment/$ec_deployment_id) || exit 1
        elastic_cloud_id=$(echo $ec_deployment | jq -r .elastic_cloud_id) || exit 1
        echo $elastic_cloud_id
    - setGlobals:
        elasticCloudDeploymentId: ${response.out}

  setAwsSnapshotRepository:
    # Parameters:
    #   - repositoryName
    #   - backupName
    #   - region
    #   - account
    #   - logsPath
    #   - awsAccessKeyId
    #   - awsSecretAccessKey
    - cmd[${nodes.cp.first.id}]: |-
        aws_access_key="${this.awsAccessKeyId}"
        aws_secret_key="${this.awsSecretAccessKey}"
        output_file=$(mktemp)
        ec_admin_credentials=${globals.ecAdminCredentials}
        return_code=$(curl -sS -o $output_file -w '%{http_code}' \
          -H 'Content-Type: application/json' \
          -u $ec_admin_credentials \
          -XPUT "https://$UNOMI_ELASTICSEARCH_ADDRESSES/_snapshot/${this.repositoryName}?verify=true&pretty" \
          -d'{
            "type": "s3",
            "settings": {
                "bucket": "'${this.account}'",
                "region": "'${this.region}'",
                "base_path" : "'${this.backupName}'/elasticsearch",
                "access_key": "'$aws_access_key'",
                "secret_key": "'$aws_secret_key'"
            }
          }')
        exit=0
        if [ $return_code -ne 200 ]; then
          cat $output_file | tee -a ${this.logsPath}
          exit=1
        fi
        rm -f $output_file
        exit $exit

  getElasticCloudApiKey:
    # Returns:
    #   ${globals.elasticCloudApiKey}
    - vaultSecretReadKeyB64:
        secretPath: paas/envs-common/elastic-cloud-api-key
        secretKey: key
    - setGlobals:
        elasticCloudApiKey: ${globals.vaultSecretData}

  getAzureElasticsearchSecret:
    # Parameters:
    #   - awsAccessKeyId
    #   - awsSecretAccessKey
    #   - backupName
    #   - operation
    #   - account
    #   - logsPath
    # Returns:
    #   ${globals.azure_secret}
    - cmd[${nodes.cp.first.id}]: |-
        export AWS_ACCESS_KEY_ID="${this.awsAccessKeyId}" AWS_SECRET_ACCESS_KEY="${this.awsSecretAccessKey}"
        cd jelastic_backup
        python3 elasticsearch.py --bucketname ${this.account} --backupname ${this.backupName} --cloudprovider=azure --operation=${this.operation} 2>>${this.logsPath} || exit 1
    - cmd[${nodes.cp.first.id}]: |-
        cat /tmp/azurecred
        rm -f /tmp/azurecred
    - setGlobals:
        azure_secret: "${response.out}"
    - if ("${globals.azure_secret}" == ""):
        - return:
            type: error
            message: "An error occurred during backup repository configuration."

  setAzureSnapshotRepository:
    # Parameters:
    #   - repositoryName
    #   - backupName
    #   - logsPath
    #   - awsAccessKeyId
    #   - awsSecretAccessKey
    #   - operation
    #   - account
    - getElasticCloudDeploymentId
    - getElasticCloudApiKey
    - getAzureElasticsearchSecret:
        awsAccessKeyId: ${this.awsAccessKeyId}
        awsSecretAccessKey: ${this.awsSecretAccessKey}
        backupName: ${this.backupName}
        operation: "${this.operation}"
        account: ${this.account}
        logsPath: ${this.logsPath}
    - cmd[${nodes.cp.first.id}]: |-
        output_file=$(mktemp)
        api_key=$(echo "${globals.elasticCloudApiKey}" | base64 -d)
        return_code=$(curl -sS -o $output_file -w '%{http_code}' \
          -H 'Content-Type: application/json' \
          -H "Authorization: ApiKey $api_key" \
          -XPATCH "https://cloud.elastic.co/api/v1/deployments/${globals.elasticCloudDeploymentId}/elasticsearch/main-elasticsearch/keystore" \
          -d'{"secrets":{"azure.client.${this.repositoryName}.account":{"value":"${this.account}"},"azure.client.${this.repositoryName}.key":{"value":"${globals.azure_secret}"}}}')
        exit=0
        if [ $return_code -ne 200 ]; then
          cat $output_file | tee -a ${globals.logsPath}
          exit=1
        fi
        rm -f $output_file
        exit $exit
    - cmd[${nodes.cp.first.id}]: |-
        output_file=$(mktemp)
        ec_admin_credentials=${globals.ecAdminCredentials}
        # First we need to reload the secure settings to take into account the ney keys in the keystore
        return_code=$(curl -sS -o $output_file -w '%{http_code}' \
          -H 'Content-Type: application/json' \
          -u $ec_admin_credentials \
          -XPOST "https://$UNOMI_ELASTICSEARCH_ADDRESSES/_nodes/reload_secure_settings")
        if [ $return_code -ne 200 ]; then
          cat $output_file | tee -a ${this.logsPath}
          rm -f $output_file
          exit 1
        fi
        sleep 5
        # Proceed only when the repository is ok or if it exceeds the 10 min window
        for (( i=1; i<=60; i++ )); do
          return_code=$(curl -sS -o $output_file -w '%{http_code}' \
            -H 'Content-Type: application/json' \
            -u $ec_admin_credentials \
            -XPUT "https://$UNOMI_ELASTICSEARCH_ADDRESSES/_snapshot/${this.repositoryName}?verify=true&pretty" \
            -d'{
              "type": "azure",
              "settings": {
                  "container": "'${this.backupName}'",
                  "base_path": "elasticsearch",
                  "client": "'${this.repositoryName}'"
              }
            }')
          if [ $return_code -eq 200 ]; then
            break
          fi
          sleep 5
        done
        exit=0
        if [ $return_code -ne 200 ]; then
          cat $output_file | tee -a ${this.logsPath}
          exit=1
        fi
        rm -f $output_file
        exit $exit


########################################### LEGACY ACTIONS ###########################################
############# TO BE REMOVED WHEN ALL ELASTICSEARCH ARE MIGRATED TO ELASTIC CLOUD #####################

  LEGACY_setAwsSnapshotRepository:
    # Parameters:
    #   - backupName
    #   - region
    #   - account
    #   - logsPath
    - cmd[${nodes.es.first.id}]: |-
        curl -H 'Content-Type: application/json' -XPUT "${nodes.es.first.intIP}:9200/_snapshot/backup_repository?verify=false&pretty" -d"
          {
            \"type\": \"s3\",
            \"settings\": {
                \"bucket\": \"${this.account}\",
                \"region\": \"${this.region}\",
                \"base_path\" : \"${this.backupName}/elasticsearch\"
            }
          }" 2>>${this.logsPath} || exit 1

  LEGACY_setAzureSnapshotRepository:
    # Parameters:
    #   - backupName
    #   - logsPath
    - cmd[${nodes.es.first.id}]: |-
        curl -H 'Content-Type: application/json' -XPUT "${nodes.es.first.intIP}:9200/_snapshot/backup_repository?verify=false&pretty" -d"
          {
            \"type\": \"azure\",
            \"settings\": {
                \"container\": \"${this.backupName}\",
                \"base_path\" : \"elasticsearch\"
            }
          }" 2>>${this.logsPath} || exit 1

  # Using an Elasticsearch keystore to add AWS keys
  LEGACY_setAwsElasticsearchConfig:
    # Parameters:
    #   - awsAccessKeyId
    #   - awsSecretAccessKey
    #   - logsPath
    - cmd[es]: |-
        aws_access_key="${this.awsAccessKeyId}"
        aws_secret_key="${this.awsSecretAccessKey}"
        if ! /usr/share/elasticsearch/bin/elasticsearch-keystore list; then
            /usr/share/elasticsearch/bin/elasticsearch-keystore create
        fi
        printf "$aws_access_key" | /usr/share/elasticsearch/bin/elasticsearch-keystore add -f s3.client.default.access_key
        printf "$aws_secret_key" | /usr/share/elasticsearch/bin/elasticsearch-keystore add -f s3.client.default.secret_key
        curl -X POST "${nodes.es.first.intIP}:9200/_nodes/reload_secure_settings" 2>>${this.logsPath} || exit 1
  LEGACY_setAzureElasticsearchConfig:
    # Parameters:
    #   - awsAccessKeyId
    #   - awsSecretAccessKey
    #   - backupName
    #   - operation
    #   - account
    #   - logsPath
    - LEGACY_getAzureElasticsearchSecret:
        awsAccessKeyId: ${this.awsAccessKeyId}
        awsSecretAccessKey: ${this.awsSecretAccessKey}
        backupName: ${this.backupName}
        operation: "${this.operation}"
        account: ${this.account}
        logsPath: ${this.logsPath}

    - cmd[es]: |-
        if ! /usr/share/elasticsearch/bin/elasticsearch-keystore list; then
            /usr/share/elasticsearch/bin/elasticsearch-keystore create
            echo "true"
        fi
        printf "${this.account}" | /usr/share/elasticsearch/bin/elasticsearch-keystore add -f azure.client.default.account
        printf "${globals.azure_secret}" | /usr/share/elasticsearch/bin/elasticsearch-keystore add -f azure.client.default.key
        curl -X POST "${nodes.es.first.intIP}:9200/_nodes/reload_secure_settings" 2>>${this.logsPath} || exit 1

  LEGACY_getAzureElasticsearchSecret:
    # Parameters:
    #   - awsAccessKeyId
    #   - awsSecretAccessKey
    #   - backupName
    #   - operation
    #   - account
    #   - logsPath
    # Returns:
    #   ${globals.azure_secret}
    - cmd[${nodes.es.first.id}]: |-
        export AWS_ACCESS_KEY_ID="${this.awsAccessKeyId}" AWS_SECRET_ACCESS_KEY="${this.awsSecretAccessKey}"
        cd jelastic_backup
        python3 elasticsearch.py --bucketname ${this.account} --backupname ${this.backupName} --cloudprovider=azure --operation=${this.operation} 2>>${this.logsPath} || exit 1
    - cmd[${nodes.es.first.id}]: |-
        cat /tmp/azurecred
        rm -f /tmp/azurecred
    - setGlobals:
        azure_secret: "${response.out}"
    - if ("${globals.azure_secret}" == ""):
        - return:
            type: error
            message: "An error occurred during backup repository configuration."

  LEGACY_calculateNumberOfReplicas:
    - if(nodes.es.length > 1):
        - if(nodes.es.length > 4):
          - setGlobals:
              - replica: 2
        - else:
          - setGlobals:
              - replica: 1
    - else:
        setGlobals:
          - replica: 0

  LEGACY_setReplica:
    - calculateNumberOfReplicas
    - forEach(nodes.cp):
        cmd[${@i.id}]: |-
          setenv=$(find /opt/jcustomer/jcustomer/bin -name setenv)
          # test if not update needed
          actual=$(awk -F'=' '/UNOMI_ELASTICSEARCH_MONTHLYINDEX_REPLICAS/ {print $NF}' $setenv)
          if [ ! -z "$actual" ]; then
            if [ $actual -eq ${globals.replica} ]; then
              echo "$(hostname) already get the good replica parameters (${globals.replica})"
              exit 0
            fi
          fi
          # some cleaning in case of an update
          sed '/^export UNOMI_ELASTICSEARCH/d' -i $setenv
          echo "export UNOMI_ELASTICSEARCH_MONTHLYINDEX_REPLICAS=${globals.replica}" >> $setenv
          echo "export UNOMI_ELASTICSEARCH_DEFAULTINDEX_REPLICAS=${globals.replica}" >> $setenv
          systemctl is-active --quiet karaf && systemctl restart karaf || exit 0
        user: root

  LEGACY_updateReplica:
    - cmd[${nodes.es.first.id}]: |-
        NODE_HOSTNAME=$(echo "${nodes.es.first.url}" | sed 's/^https:\/\///')
        curl -s http://${NODE_HOSTNAME}:9200/_cat/indices | awk -v repl=${this.replica} '$6!=repl {print $3}' | while read index; do
            curl -s -XPUT http://${NODE_HOSTNAME}:9200/$index/_settings \
              -H "Content-Type: application/json" \
              -d '{"index":{"number_of_replicas": ${this.replica} }}' 2>>${this.logsPath}
        done
