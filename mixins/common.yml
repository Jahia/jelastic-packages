---
actions:
  setGlobalRepoRootUrl:
    # Gets the repository root URL and set it in a global named "repoRootUrl", WITH NO TRAILING SLASH
    # Examples:
    #   repoRootUrl = https://github.com/Jahia/jelastic-packages/raw/master
    #   repoRootUrl = https://raw.githubusercontent.com/Jahia/jelastic-packages/master
    - if(!globals.repoRootUrl):
        - script: |-
            var baseUrl = "${baseUrl}"
            var regex = /https:\/\/(raw\.)?github\w*\.com\/Jahia\/[^\/]+\/(raw\/)?[^\/]+/
            var repoRootUrl = baseUrl.match(regex)
            return {"result": 0, "root_url": repoRootUrl[0]}
        - setGlobals:
            repoRootUrl: ${response.root_url}
    - else:
        log: "[INFO] global repoRootUrl is already defined with value '${globals.repoRootUrl}'"

  setSudoer:
    - log: "## Set sudoer on ${this}"
    - cmd[${this}]: |-
        touch /etc/sudoers.d/sudo
        # Warning : it only works if jelastic user exists, which may be compromised
        # if using a non-Jelastic docker image
        USER=$(id -nu $(id -u jelastic))
        echo "$USER ALL=NOPASSWD: ALL" >> /etc/sudoers.d/sudo
        echo "jelastic ALL=NOPASSWD: ALL" >> /etc/sudoers.d/sudo
      user: root
    - if ("${response.errOut}" != ""):
        - return:
            type: error
            message: "An error occurred during sudoers configuration."

  setJournaldLimit:
    - cmd[*]: |-
        sed -i 's/.*SystemMaxUse=.*/SystemMaxUse=200M/g' /etc/systemd/journald.conf
        systemctl restart systemd-journald.service
      user: root
    - if ("${response.errOut}" != ""):
        - return:
            type: error
            message: "An error occurred while configuring journald."

  checkIfEnvExists:
    # Set the global check_env_exists to true if the env exists, false otherwise
    # parameters:
    #  - envName
    script: |-
      response = jelastic.env.control.GetEnvInfo("${this.envName}", session);
      res = {"result": 0}
      res.onAfterReturn = {
        setGlobals: {
          check_env_exists: response.result == 0
        }
      }
      return res

  setEnvVersion:
  # If the parameter is not an integer, we don't set the env version
    - if (/^[0-9]+$/.test(${this})):
        - script: |
            return api.env.nodegroup.ApplyData("${env.envName}", session, "cp", { envVersion: ${this} });
    - else:
        - log: "The parameter '${this}' is not an integer, nothing to do"


  checkEnvVersion:
    - script: |-
        const currentVersion = jelastic.env.control.GetNodeGroups("${env.envName}", session).object.filter(function (object) {
            return object.name == "cp";
        }).pop().envVersion;
        if (${this} <= currentVersion) {
            return {'result': 1, 'error': 'Environment is already up-to-date'}
        } else {
            return {'result': 0, 'out': 'Environment needs to be updated'}
        }

  getLogEventScript:
    - setGlobalRepoRootUrl
    - cmd[${this}]: |-
        curl -fLSso /usr/local/bin/log_event.sh ${globals.repoRootUrl}/assets/common/log_events.sh || exit 1
        chmod u+x /usr/local/bin/log_event.sh
      user: root

  logEvent:
    # Check if env is running (status = 1)
    if (1 == ${env.status}):
      cmd[${this.target}]: |-
        /usr/local/bin/log_event.sh "${this.title}" "${this.text}"
      user: root

  manageSystemdService:
    # Parameters:
    #   - target
    #   - unit
    #   - action
    - cmd[${this.target}]: systemctl ${this.action} ${this.unit}
      user: root

  setCloudConf:
    # Grab dev/preprod/prod infrastructure conf file
    # and create "cloud_conf" nodegroup data from it on cp
    - setGlobalRepoRootUrl
    - cmd[${nodes.cp.first.id}]: |-
        metadata_file="/metadata_from_HOST"
        timeout=$((SECONDS+120))
        while [ $SECONDS -lt $timeout ]; do
          if [ -s $metadata_file ]; then
            eval $(grep "^JEL_ENV_ROLE=" /metadata_from_HOST)
            file="${JEL_ENV_ROLE}.conf.json"
            r=$(curl -LsSo /tmp/$file -w '%{http_code}' ${globals.repoRootUrl}/conf/$file)
            if [ $r -eq 200 ]; then
              cat /tmp/$file && rm -f /tmp/$file
              exit 0
            else
              echo "Error on ${globals.repoRootUrl}/conf/$file download, return code: $r" 1>&2
              exit 1
            fi
          fi
          sleep 0.5
        done
        echo "$metadata_file doesn't exist or has a size of 0 byte." 1>&2
        exit 2
    - api: env.control.ApplyNodeGroupData
      nodeGroup: cp
      data: ${response.out.toJSON()}

  getCloudConf:
    # Grab cp's nodegroup data "cloud_conf"
    # and export globals.cloud_conf
    - script: |-
        conf = jelastic.env.control.getnodegroups('${env.envName}', session).object.filter(function (object) {
                 return object.name == "cp"}).pop().cloud_conf
        if (conf == null) {
          return {"result": 1, "error": "Can't found 'cloud_conf' in nodegroup data"}
        } else {
          setglobals = {setGlobals: {cloud_conf: conf}}
          return {"result": 0, onAfterReturn: setglobals}
        }

  ###################
  # COMPARE VERSION #
  ###################
  compareVersions:
    # Parameters :
    #  a : the first version to compare
    #  b : the second version to compare
    #  res : the global variable name to store the result
    # Returns:
    # 1 if a > b
    # 0 if a = b
    # -1 if a < b
    - script: |-
        function compare(index) {
          if (index > a.length)
            return 0;

          aDigit = parseInt(a[index]);
          bDigit = parseInt(b[index]);

          if (aDigit < bDigit)
            return -1;
          else if (aDigit > bDigit)
            return 1;
          else
            return compare(index+1)
        }

        const a = "${this.a}".split('.');
        const b = "${this.b}".split('.')

        if (a.length != b.length)
          return {"result": 1, "error": "invalid parameters"}

        return {"result": 0, "outcome": compare(0)}

    - setGlobals:
        versionIsGreater: 1
        versionIsEqual: 0
        versionIsLower: -1
        ${this.res}: ${response.outcome}

  isVersionStrictlyLower:
    # Parameters :
    #  a : the first version to compare
    #  b : the second version to compare
    #  res : the global variable name to store the result
    # Returns:
    # 1 if a < b
    # 0 if a >= b
    - compareVersions:
        a: "${this.a}"
        b: "${this.b}"
        res: isVersionStrictlyLowerComparison
    - if (${globals.isVersionStrictlyLowerComparison} == -1):
        setGlobals:
          ${this.res}: true
    - else:
        setGlobals:
          ${this.res}: false

  isVersionStrictlyHigher:
    # Parameters :
    #  a : the first version to compare
    #  b : the second version to compare
    #  res : the global variable name to store the result
    # Returns:
    # 1 if a > b
    # 0 if a <= b
    - compareVersions:
        a: "${this.a}"
        b: "${this.b}"
        res: isVersionStrictlyHigherComparison
    - if (${globals.isVersionStrictlyHigherComparison} == 1):
        setGlobals:
          ${this.res}: true
    - else:
        setGlobals:
          ${this.res}: false

  isVersionEqual:
    # Parameters :
    #  a : the first version to compare
    #  b : the second version to compare
    #  res : the global variable name to store the result
    # Returns:
    # 1 if a == b
    # 0 if a != b
    - compareVersions:
        a: "${this.a}"
        b: "${this.b}"
        res: isVersionEqualComparison
    - if (${globals.isVersionEqualComparison} == 0):
        setGlobals:
          ${this.res}: true
    - else:
        setGlobals:
          ${this.res}: false

  isVersionBetween:
    # Parameters :
    #  lower : the lower version to compare
    #  lower_may_equal : true is version can be equal to lower, false otherwise
    #  version : the version number to check
    #  higher : the higher version to compare
    #  higher_may_equal : true is version can be equal to higher, false otherwise
    #  res : the global variable name to store the result
    # Returns:
    # true if lower < version < higher and both *_may_equal are false
    # true if lower <= version <= higher and both *_may_equal are true
    # true if lower <= version < higher and only lower_may_equal is true
    # true if lower < version <= higher and only higher_may_equal is true
    # false otherwise
    - set:
        is_ok: false
    - compareVersions:
        a: "${this.lower}"
        b: "${this.higher}"
        res: areBoundsOK
    - if ( ${globals.areBoundsOK} <= 0):
        - compareVersions:
            a: "${this.lower}"
            b: "${this.version}"
            res: isLowerLower
        - compareVersions:
            a: "${this.version}"
            b: "${this.higher}"
            res: isHigherHigher
        - if (! ${this.lower_may_equal} && ! ${this.higher_may_equal}):
            - if (${globals.isLowerLower} == -1 && ${globals.isHigherHigher} == -1):
                - set:
                    is_ok: true
        - elif (${this.lower_may_equal} && ${this.higher_may_equal}):
            - if (${globals.isLowerLower} <= 0 && ${globals.isHigherHigher} <= 0):
                - set:
                    is_ok: true
        - elif (${this.lower_may_equal} && ! ${this.higher_may_equal}):
            - if (${globals.isLowerLower} <= 0 && ${globals.isHigherHigher} < 0):
                - set:
                    is_ok: true
        - elif (! ${this.lower_may_equal} && ${this.higher_may_equal}):
            - if (${globals.isLowerLower} < 0 && ${globals.isHigherHigher} <= 0):
                - set:
                    is_ok: true
    - else:
        - log: "[ERROR] Boundaries are not valid: '${this.lower}<=${this.higher}' is false"
        - return:
            type: error
            message: "Boundaries are not valid: '${this.lower}<=${this.higher}' is false"
    - if (${this.is_ok}):
        - setGlobals:
            ${this.res}: true
    - else:
        - setGlobals:
            ${this.res}: false

  isVersionLowerOrEqual:
    # Parameters :
    #  a : the first version to compare
    #  b : the second version to compare
    #  res : the global variable name to store the result
    # Returns:
    # 1 if a <= b
    # 0 if a > b
    - compareVersions:
        a: "${this.a}"
        b: "${this.b}"
        res: isVersionLowerOrEqualComparison
    - if (${globals.isVersionLowerOrEqualComparison} <= 0):
        setGlobals:
          ${this.res}: true
    - else:
        setGlobals:
          ${this.res}: false

  isVersionHigherOrEqual:
    # Parameters :
    #  a : the first version to compare
    #  b : the second version to compare
    #  res : the global variable name to store the result
    # Returns:
    # 1 if a >= b
    # 0 if a < b
    - compareVersions:
        a: "${this.a}"
        b: "${this.b}"
        res: isVersionHigherOrEqualComparison
    - if (${globals.isVersionHigherOrEqualComparison} >= 0):
        setGlobals:
          ${this.res}: true
    - else:
        setGlobals:
          ${this.res}: false

  installBackupTools:
    - setGlobalRepoRootUrl
    - cmd [${this.target}]: |-
        ## [${this.logAction}] - 1/5
        sudo python3 -m pip install --upgrade pip
        sudo python3 -m pip install --upgrade boto3 "azure==4.0.0" adal
        [ -d jelastic_backup ] || mkdir jelastic_backup
        cd jelastic_backup
        for file in backrest.py lib_aws.py lib_azure.py revisionNode.py; do
          curl -fLSso $file ${globals.repoRootUrl}/assets/common/$file || exit 1
        done
        curl -fLSso elasticsearch.py ${globals.repoRootUrl}/assets/elasticsearch/elasticsearch.py || exit 1

  clearJelasticLogs:
    - cmd[${this.target}]: echo "" > ${this.logsPath}; chown ${this.user}:root ${this.logsPath}
      user: root

  checkDatadogAgentCheck:
    # Parameters :
    #  - target: target node group or id
    #  - checkName: name of the Datadog agent check to check
    - cmd[${this.target}]: |-
        error_count=$(datadog-agent check ${this.checkName} --json | jq '.[].runner.TotalErrors')
        if [ $error_count -gt 0 ]; then
          echo "[ERROR] Datadog agent's '${this.checkName}' check failed" >&2
          exit 1
        fi
      user: root

  updateDatadogAgentToLatest:
    - cmd[*]: |-
        source /.jelenv
        export DD_AGENT_MAJOR_VERSION=6
        export DD_API_KEY=$DATADOGAPIKEY
        bash -c "$(curl -L https://s3.amazonaws.com/dd-agent/scripts/install_script.sh)"
      user: root

  installRequiredPackages:
    # Parameters :
    #  - target: target node group or id
    #  - packages: name of the packages to install, space separated
    - setGlobalRepoRootUrl
    - cmd [${this.target}]: |-
        packages_to_install=()
        for package in ${this.packages}; do
          if ! rpm --quiet -q $package; then
            echo "$package needs to be installed"
            packages_to_install+=("$package")
          fi
        done
        [[ "${packages_to_install[@]}" == "" ]] || yum --setopt=tsflags=nodocs install -y ${packages_to_install[@]};
      user: root

  installPapiScript:
    - setGlobalRepoRootUrl
    - cmd [${this}]: |-
        python3 -m pip install --upgrade pip
        python3 -m pip install requests
        curl -fLSso /usr/local/bin/papi.py ${globals.repoRootUrl}/assets/common/papi.py || exit 1
        chmod 755 /usr/local/bin/papi.py
      user: root

  ###################
  # Vault actions   #
  ###################
  vaultAppRoleLogin:
    # Returns:
    #   ${globals.__secret__vaultToken}
    - set:
        generateNewToken: true
    - script: |
        import org.apache.http.client.methods.HttpGet;
        import org.apache.http.impl.client.HttpClients;
        __secret__vaultToken = "${globals.__secret__vaultToken}";
        httpGet = new HttpGet("${globals.vaultClusterUrl}/v1/auth/token/lookup-self");
        httpGet.setHeader("X-Vault-Token", __secret__vaultToken);
        httpClient = HttpClients.createDefault();
        resp = httpClient.execute(httpGet).getStatusLine().getStatusCode();
        if (resp != 200) {
          return {"result": 0, out: "Token is not valid, it needs to be renewed" };
        }
          return {"result": 0, out: ""};
    - if ("${response.out}" == ""):
        set:
          generateNewToken: false
    - if ("${this.generateNewToken}" == "true"):
        - script: |
            import org.apache.http.client.methods.HttpPost;
            import org.apache.http.impl.client.HttpClients;
            import org.apache.http.util.EntityUtils;
            import org.apache.http.entity.StringEntity;
            __secret__vaultRoleId = "${globals.__secret__vaultRoleId}";
            __secret__vaultSecretId = "${globals.__secret__vaultSecretId}";
            httpPost = new HttpPost("${globals.vaultClusterUrl}/v1/auth/approle/login");
            json = toJSON({
                  "role_id": __secret__vaultRoleId,
                  "secret_id": __secret__vaultSecretId
                  }
             );
            stringEntity = new StringEntity(json);
            httpPost.setEntity(stringEntity);
            httpClient = HttpClients.createDefault();
            resp = httpClient.execute(httpPost);
            if (resp.getStatusLine().getStatusCode() != 200) {
              return {"result": 1, errOut: "Can't generate vault token with appRole login" };
            }
            data = JSON.parse(EntityUtils.toString(resp.getEntity()));
            vaultToken = data["auth"]["client_token"];
            return {
              "result": 0,
              "onAfterReturn": {
                setGlobals: {
                  "__secret__vaultToken": vaultToken
                }
              }
            };

  vaultSecretExists:
    # Check if a secret exists. It must be in an authorized path for the env token, otherwise it will fail and exit
    # Parameters:
    #   - secretPath: path (and name) of the secret to check
    # Returns:
    #   ${globals.secretExists}: A boolean set to true if the secret exists. Set to false otherwise
    - vaultAppRoleLogin
    - script: |
        import org.apache.http.client.methods.HttpGet;
        import org.apache.http.impl.client.HttpClients;
        import org.apache.http.util.EntityUtils;
        import java.util.Base64;
        __secret__vaultToken = "${globals.__secret__vaultToken}";
        httpGet = new HttpGet("${globals.vaultClusterUrl}/v1/kv/data/${this.secretPath}");
        httpGet.setHeader("X-Vault-Token", __secret__vaultToken);
        httpClient = HttpClients.createDefault();
        resp = httpClient.execute(httpGet);
        statusCode = resp.getStatusLine().getStatusCode();
        if (statusCode == 200 ) {
          return {"result": 0, "message": "Secret exists", "secretExists": true};
        } else if (statusCode == 404 ) {
          return {"result": 0, "message": "Secret does not exist", "secretExists": false};
        } else {
          return {"result": 1, "message": "Error: " + resp};
        }
    - setGlobals:
        secretExists: ${response.secretExists}

  vaultSecretReadAllKeysB64:
    # Parameters:
    #   - secretPath: path (and name) of the secret to fetch
    # Returns:
    #   ${globals.__secret__vaultSecretData}: A JSON string with all key and data for the specified secret, base64 encoded
    - vaultAppRoleLogin
    - script: |
        import org.apache.http.client.methods.HttpGet;
        import org.apache.http.impl.client.HttpClients;
        import org.apache.http.util.EntityUtils;
        import java.util.Base64;
        __secret__vaultToken = "${globals.__secret__vaultToken}";
        httpGet = new HttpGet("${globals.vaultClusterUrl}/v1/kv/data/${this.secretPath}");
        httpGet.setHeader("X-Vault-Token", __secret__vaultToken);
        httpClient = HttpClients.createDefault();
        resp = httpClient.execute(httpGet);
        if (resp.getStatusLine().getStatusCode() != 200) {
          return {"result": 1, errOut: "Can't read secret ${this.secretPath}" };
        }
        data = JSON.parse(EntityUtils.toString(resp.getEntity()));
        secrets = java.lang.String(data["data"]["data"]);
        secretsB64 = Base64.getEncoder().encodeToString(secrets.getBytes());
        return {
          "result": 0,
          "onAfterReturn": {
            setGlobals: {
              "__secret__vaultSecretData": secretsB64
            }
          }
        };

  vaultSecretReadKeyB64:
    # Parameters:
    #   - secretPath: path (and name) of the secret to fetch
    #   - secretKey: the secret's key
    # Returns:
    #   ${globals.__secret__vaultSecretData}: the specified secret's data, base64 encoded
    - vaultAppRoleLogin
    - script: |
        import org.apache.http.client.methods.HttpGet;
        import org.apache.http.impl.client.HttpClients;
        import org.apache.http.util.EntityUtils;
        import java.util.Base64;
        __secret__vaultToken = "${globals.__secret__vaultToken}";
        httpGet = new HttpGet("${globals.vaultClusterUrl}/v1/kv/data/${this.secretPath}");
        httpGet.setHeader("X-Vault-Token", __secret__vaultToken);
        httpClient = HttpClients.createDefault();
        resp = httpClient.execute(httpGet);
        if (resp.getStatusLine().getStatusCode() != 200) {
          return {"result": 1, errOut: "Can't read secret ${this.secretPath}" };
        }
        data = JSON.parse(EntityUtils.toString(resp.getEntity()));
        secret = java.lang.String(data["data"]["data"]["${this.secretKey}"]);
        secretB64 = Base64.getEncoder().encodeToString(secret.getBytes());
        return {
          "result": 0,
          "onAfterReturn": {
            setGlobals: {
              "__secret__vaultSecretData": secretB64
            }
          }
        };

  vaultSecretSet:
    # Parameters:
    #   - secretPath: path (and name) of the secret to set
    #   - __secret__secretData: the secret's data ex: {"foo": "bar","zip": "zap"}
    - vaultAppRoleLogin
    - script: |
        import org.apache.http.client.methods.HttpPost;
        import org.apache.http.impl.client.HttpClients;
        import org.apache.http.util.EntityUtils;
        import org.apache.http.entity.StringEntity;
        __secret__secretData = ${this.__secret__secretData};
        __secret__vaultToken = "${globals.__secret__vaultToken}";
        secretPath = "${this.secretPath}";

        httpPost = new HttpPost("${globals.vaultClusterUrl}/v1/kv/data/" + secretPath);
        httpPost.setHeader("X-Vault-Token", __secret__vaultToken);
        json = toJSON({"data": __secret__secretData});
        stringEntity = new StringEntity(json);
        httpPost.setEntity(stringEntity);
        httpClient = HttpClients.createDefault();
        resp = httpClient.execute(httpPost);
        if (resp.getStatusLine().getStatusCode() != 200) {
          return {"result": 1, errOut: "Can't update/create secret " + secretPath + ". " + resp };
        }

        return {"result": 0}

  vaultSecretDelete:
    # Parameters:
    #   - secretPath: path of the secret to delete
    - vaultAppRoleLogin
    - script: |
        import org.apache.http.client.methods.HttpDelete;
        import org.apache.http.client.methods.HttpGet;
        import org.apache.http.impl.client.HttpClients;
        import org.apache.http.util.EntityUtils;
        __secret__vaultToken = "${globals.vaultToken}";
        secretDelete = new HttpDelete("${globals.vaultClusterUrl}/v1/kv/metadata/${this.secretPath}");
        secretDelete.setHeader("X-Vault-Token", __secret__vaultToken);
        httpClient = HttpClients.createDefault();
        resp = httpClient.execute(secretDelete);
        if (resp.getStatusLine().getStatusCode() != 204) {
          return {"result": 1, errOut: "Can't delete secret from ${this.secretPath}" };
        }
        return {"result": 0, out: "Secret has been deleted"};

  removeAllSecrets:
    - getVaultData
    - setGlobals:
        vaultSecretsList: papi;haproxy;ipsec/conn-1;PAT/root

    - script: |-
        return {"result": 0, "secrets": "${globals.vaultSecretsList}".split(";")}

    - forEach(response.secrets):
        vaultSecretDelete:
          secretPath: "paas/customers/${globals.organizationName}/paas_${env.shortdomain}/${@i}"

  getBackrestAwsAccessKey:
    # Returns:
    #   ${globals.__secret__backrestAwsAccessKeyId}: Access key ID of backrest AWS user
    #   ${globals.__secret__backrestAwsSecretAccessKey}: Access secret key of backrest AWS user
    - getVaultData
    - vaultSecretReadAllKeysB64:
        secretPath: "paas/envs-common/aws-backrest"
    - script: |-
        let __secret__vaultResponseBase64 = "${globals.__secret__vaultSecretData}";
        let vaultResponse = JSON.parse(java.lang.String(java.util.Base64.getDecoder().decode(__secret__vaultResponseBase64)))
        return {
          "result": 0,
          "onAfterReturn": {
            setGlobals: {
              "__secret__backrestAwsAccessKeyId": vaultResponse.access_key_id,
              "__secret__backrestAwsSecretAccessKey": vaultResponse.secret_access_key
            }
          }
        };

  muteDatadogHost:
    # Parameters:
    #  - target: target node group or id
    #  - duration: mute duration in minutes. Optional, default 60
    - getVaultData
    - vaultSecretReadKeyB64:
        secretPath: "paas/customers/${globals.organizationName}/common/datadog"
        secretKey: "datadog_app_key"
    - cmd[${this.target}]: |-
        DD_HOSTNAME=$(awk '$1=="hostname:" {print $2}' /etc/datadog-agent/datadog.yaml)
        __secret__DD_APP_KEY=$(echo -n "${globals.__secret__vaultSecretData}" | base64 -d)

        MUTE_END=$(date -d "+${this.duration:60}min" +%s)

        curl "https://api.datadoghq.com/api/v1/host/$DD_HOSTNAME/mute" \
          -XPOST \
          -H 'Content-Type: application/json' \
          -H "DD-API-KEY: $DATADOGAPIKEY" \
          -H "DD-APPLICATION-KEY: $__secret__DD_APP_KEY"  \
          -d "{\"end\": $MUTE_END, \"action\":\"Muted\", \"override\": \"true\"}"
        exit 0  # always exit with 0 so that Jelastic does not stop there in case of problems with Datadog
      user: root

  unmuteDatadogHost:
    # Parameters:
    #  - target: target node group or id
    - getVaultData
    - vaultSecretReadKeyB64:
        secretPath: "paas/customers/${globals.organizationName}/common/datadog"
        secretKey: "datadog_app_key"
    - cmd[${this.target}]: |-
        DD_HOSTNAME=$(awk '$1=="hostname:" {print $2}' /etc/datadog-agent/datadog.yaml)
        __secret__DD_APP_KEY=$(echo -n "${globals.__secret__vaultSecretData}" | base64 -d)

        curl "https://api.datadoghq.com/api/v1/host/$DD_HOSTNAME/unmute" \
          -XPOST \
          -H "DD-API-KEY: $DATADOGAPIKEY" \
          -H "DD-APPLICATION-KEY: $__secret__DD_APP_KEY"
      user: root


  getPapiInfoAll:
    - getVaultData
    - vaultSecretReadKeyB64:
        secretPath: "paas/customers/${globals.organizationName}/paas_${env.envName}/papi"
        secretKey: "token"
    - setGlobals:
        __secret__papiToken: '${globals.__secret__vaultSecretData.fromBase64()}'
    - getPapiData

  updateEnvStatusInPapi:
    # Parameters:
    #  - status: stopped, running, creating
    - if ("HideThisLine" && "${globals.papiToken.print()}" == ""):
        getPapiInfoAll
    - cmd[${nodes.cp.first.id}]: |-
        __secret__PAPI_TOKEN="${globals.__secret__papiToken}"
        export PAPI_TOKEN="$__secret__PAPI_TOKEN"
        export PAPI_HOSTNAME="${globals.papiHostname}"
        export PAPI_ENV_ID="${globals.papiEnvId}"
        export PAPI_API_VERSION="${globals.papiApiVersion}"
        papi.py -X PUT -d '{"status": "${this.status}"}' paas-environment/$PAPI_ENV_ID


  updateProductVersionInPapi:
    # Parameters:
    #  - product: dx, unomi
    #  - version: product verion
    - if ("HideThisLine" && "${globals.papiToken.print()}" == ""):
        getPapiInfoAll
    - cmd[${nodes.cp.first.id}]: |-
        __secret__PAPI_TOKEN="${globals.__secret__papiToken}"
        export PAPI_TOKEN="$__secret__PAPI_TOKEN"
        export PAPI_HOSTNAME="${globals.papiHostname}"
        export PAPI_ENV_ID="${globals.papiEnvId}"
        export PAPI_API_VERSION="${globals.papiApiVersion}"
        version=$(echo "${this.product}_${this.version}" | tr -s '.' '-')
        papi.py -X PUT -d "{\"paas_product_version_id\": \"$version\"}" paas-environment/$PAPI_ENV_ID

  setEnvironmentAppId:
    - if ("HideThisLine" && "${globals.papiToken.print()}" == ""):
        getPapiInfoAll
    - cmd[${nodes.cp.first.id}]: |-
        __secret__PAPI_TOKEN="${globals.__secret__papiToken}"
        export PAPI_TOKEN="$__secret__PAPI_TOKEN"
        export PAPI_HOSTNAME="${globals.papiHostname}"
        export PAPI_ENV_ID="${globals.papiEnvId}"
        export PAPI_API_VERSION="${globals.papiApiVersion}"
        papi.py -X PUT -d '{"jelastic_appid": "${env.appid}"}' paas-environment/$PAPI_ENV_ID

  deleteEnvironment:
    - if ("HideThisLine" && "${globals.papiToken.print()}" == ""):
        getPapiInfoAll
    - script: |
        import org.apache.http.client.methods.HttpGet;
        import org.apache.http.impl.client.HttpClients;
        import org.apache.http.util.EntityUtils;
        __secret__papiToken = "${globals.__secret__papiToken}";
        getPaasEnv = new HttpGet("https://${globals.papiHostname}/api/${globals.papiApiVersion}/paas-environment/${globals.papiEnvId}");
        getPaasEnv.setHeader("X-PAPI-KEY", __secret__papiToken);
        httpClient = HttpClients.createDefault();
        resp = httpClient.execute(getPaasEnv);
        if (resp.getStatusLine().getStatusCode() != 200) {
          return {"result": 1, errOut: "Can't get paas environment " + "${globals.papiEnvId}" };
        }
        paasEnv = JSON.parse(EntityUtils.toString(resp.getEntity()));
        papierId = paasEnv["papier_id"]
        return {'result': 0, 'papierId': papierId };
    - setGlobals:
        papierId: ${response.papierId}
    - script: |
        import org.apache.http.client.methods.HttpDelete;
        import org.apache.http.impl.client.HttpClients;
        import org.apache.http.util.EntityUtils;
        __secret__papiToken = "${globals.__secret__papiToken}";
        paasEnvDelete = new HttpDelete("https://${globals.papiHostname}/api/${globals.papiApiVersion}/paas-environment/${globals.papiEnvId}");
        paasEnvDelete.setHeader("X-PAPI-KEY", __secret__papiToken);
        httpClient = HttpClients.createDefault();
        resp = httpClient.execute(paasEnvDelete);
        if (resp.getStatusLine().getStatusCode() != 204) {
          return {"result": 1, errOut: "Can't delete paas environment " + "${globals.papiEnvId}" };
        }
        papierDelete = new HttpDelete("https://${globals.papiHostname}/api/${globals.papiApiVersion}/papier/${globals.papierId}");
        papierDelete.setHeader("X-PAPI-KEY", papiToken);
        resp1 = httpClient.execute(papierDelete);
        if (resp1.getStatusLine().getStatusCode() != 204) {
          return {"result": 1, errOut: "Can't delete papier " + "${globals.papierId}" };
        }
        return {'result': 0, 'out': "Paas Environment - ${globals.papiEnvId} and Papier - ${globals.papierId} has been deleted" };

  addEnvMetadataToNodeGroup:
    - cmd[cp]: echo "${user.email}" | cut -d'@' -f1
    - set:
        organizationName: ${response.out}
    - script: |-
        orgName = "${this.organizationName}";
        __secret__vaultRoleId = "${this.__secret__vaultRoleId}";
        __secret__vaultSecretId = "${this.__secret__vaultSecretId}";
        vaultClusterUrl = "${this.vaultClusterUrl}";
        papiHostname = "${this.papiHostname}";
        papiApiVersion = "${this.papiApiVersion}";
        papiEnvId = "${this.papiEnvId}";

        return jelastic.env.control.ApplyNodeGroupData(
          '${env.envName}',
          session,
          nodeGroup='cp',
          data={"ORGANIZATION_NAME": orgName,
                "VAULT_ROLE_ID": __secret__vaultRoleId,
                "VAULT_SECRET_ID": __secret__vaultSecretId,
                "VAULT_CLUSTER_URL": vaultClusterUrl,
                "PAPI_HOSTNAME": papiHostname,
                "PAPI_API_VERSION": papiApiVersion,
                "PAPI_ENV_ID": papiEnvId
              }
        );

  setJelEnvRoleInNodeGroupData:
    - cmd[${nodes.cp.first.id}]: |-
        source /metadata_from_HOST
        if [ -z $JEL_ENV_ROLE ]; then
          echo "JEL_ENV_ROLE variable is not defined in /metadata_from_HOST"
          exit 1
        fi
        echo $JEL_ENV_ROLE

    - environment.nodegroup.ApplyData [cp]:
        data:
          JEL_ENV_ROLE: ${response.out}

  getVaultData:
    - script: |
        const envName = "${env.envName}";
        orgName = jelastic.env.control.GetNodeGroups(envName, session).object.filter(function (object) {
                                        return object.name == "cp";}).pop().ORGANIZATION_NAME;
        vaultUrl = jelastic.env.control.GetNodeGroups(envName, session).object.filter(function (object) {
                                        return object.name == "cp";}).pop().VAULT_CLUSTER_URL;
        roleId = jelastic.env.control.GetNodeGroups(envName, session).object.filter(function (object) {
                                        return object.name == "cp";}).pop().VAULT_ROLE_ID;
        secretId = jelastic.env.control.GetNodeGroups(envName, session).object.filter(function (object) {
                                        return object.name == "cp";}).pop().VAULT_SECRET_ID;
        return {
          "result": 0,
          "onAfterReturn": {
            setGlobals: {
              "organizationName": orgName,
              "vaultClusterUrl": vaultUrl,
              "__secret__vaultRoleId": roleId,
              "__secret__vaultSecretId": secretId
            }
          }
        };       

  getPapiData:
    - script: |
        const envName = "${env.envName}";
        papiEnvId = jelastic.env.control.GetNodeGroups(envName, session).object.filter(function (object) {
                                        return object.name == "cp";}).pop().PAPI_ENV_ID;
        papiHostname = jelastic.env.control.GetNodeGroups(envName, session).object.filter(function (object) {
                                        return object.name == "cp";}).pop().PAPI_HOSTNAME;
        papiApiVersion = jelastic.env.control.GetNodeGroups(envName, session).object.filter(function (object) {
                                        return object.name == "cp";}).pop().PAPI_API_VERSION;
        return {
          'result': 0,
          'papi_env_id': papiEnvId,
          'papi_hostname': papiHostname,
          'papi_api_version': papiApiVersion
        };
    - setGlobals:
        papiApiVersion: ${response.papi_api_version}
        papiEnvId: ${response.papi_env_id}
        papiHostname: ${response.papi_hostname}

  getEnvStatus:
    # Parameters:
    #   - envName: Env name of linked jahia or jcustomer
    - script: |
        resp = jelastic.env.control.GetEnvInfo('${this.envName}', session);
        return {"result": 0, "out": resp.env.status};

  muteDatadogSynthetics:
    # Parameters:
    #  - duration: mute duration in minutes. Optional, default 60
    - getVaultData
    - vaultSecretReadKeyB64:
        secretPath: "paas/customers/${globals.organizationName}/common/datadog"
        secretKey: "datadog_app_key"
    - cmd[${nodes.cp.first.id}]: |-
        __secret__DD_APP_KEY=$(echo -n "${globals.__secret__vaultSecretData}" | base64 -d)
        DD_SYNTHETICS_TEST=https://api.datadoghq.com/api/v1/synthetics/tests
        MUTE_END=$(date -d "+${this.duration:60}min" +%s)
        monitor_id=$(curl -s $DD_SYNTHETICS_TEST \
                      -H 'Content-Type: application/json' \
                      -H "DD-API-KEY: $DATADOGAPIKEY" \
                      -H "DD-APPLICATION-KEY: $__secret__DD_APP_KEY" \
                      | jq -er '.tests[] | select(.config.request.url | contains("https://${env.shortdomain}.")) | .monitor_id')
        if [[ $? -ne 0 ]]; then
          echo "[INFO] No synthetics defined for ${env.envName}"
          exit 0
        fi
        DD_MONITOR_SEARCH=https://api.datadoghq.com/api/v1/monitor/search?query=synthetics
        monitor_mute_status=$(curl -s $DD_MONITOR_SEARCH \
                             -H 'Content-Type: application/json' \
                             -H "DD-API-KEY: $DATADOGAPIKEY" \
                             -H "DD-APPLICATION-KEY: $__secret__DD_APP_KEY" \
                             | jq -er '.monitors[] | select(.id | contains('$monitor_id')) | .muted_until_ts')
        if [ $monitor_mute_status != null ]; then
          echo "[INFO] Synthetics is already muted. Nothing to do."
          exit 0
        fi
        curl -s "https://api.datadoghq.com/api/v1/monitor/$monitor_id/mute" \
          -XPOST \
          -H 'Content-Type: application/json' \
          -H "DD-API-KEY: $DATADOGAPIKEY" \
          -H "DD-APPLICATION-KEY: $__secret__DD_APP_KEY" \
          -d "{\"end\": $MUTE_END}"

  unmuteDatadogSynthetics:
    - getVaultData
    - vaultSecretReadKeyB64:
        secretPath: "paas/customers/${globals.organizationName}/common/datadog"
        secretKey: "datadog_app_key"
    - cmd[${nodes.cp.first.id}]: |-
        __secret__DD_APP_KEY=$(echo -n "${globals.__secret__vaultSecretData}" | base64 -d)
        DD_SYNTHETICS_TEST=https://api.datadoghq.com/api/v1/synthetics/tests
        monitor_id=$(curl -s $DD_SYNTHETICS_TEST \
                    -H 'Content-Type: application/json' \
                    -H "DD-API-KEY: $DATADOGAPIKEY" \
                    -H "DD-APPLICATION-KEY: $__secret__DD_APP_KEY" \
                    | jq -er '.tests[] | select(.config.request.url | contains("https://${env.shortdomain}.")) | .monitor_id')
        if [[ $? -ne 0 ]]; then
          echo "[INFO] No synthetics defined for ${env.envName}"
          exit 0
        fi
        DD_MONITOR_SEARCH=https://api.datadoghq.com/api/v1/monitor/search?query=synthetics
        monitor_mute_status=$(curl -s $DD_MONITOR_SEARCH \
                             -H 'Content-Type: application/json' \
                             -H "DD-API-KEY: $DATADOGAPIKEY" \
                             -H "DD-APPLICATION-KEY: $__secret__DD_APP_KEY" \
                             | jq -er '.monitors[] | select(.id | contains('$monitor_id')) | .muted_until_ts')
        if [ $monitor_mute_status == null ]; then
          echo "[INFO] Synthetics is already unmuted. Nothing to do."
          exit 0
        fi
        # Iterating over the monitor status and unmute it once monitor status is 'OK'
        # Once max iterations(~5mins for 180 iterations) is reached, we unmute the monitor regardless of the status.
        for (( i=1; i<=180; i++ )); do
          monitor_status=$(curl -s $DD_MONITOR_SEARCH \
                          -H 'Content-Type: application/json' \
                          -H "DD-API-KEY: $DATADOGAPIKEY" \
                          -H "DD-APPLICATION-KEY: $__secret__DD_APP_KEY" \
                          | jq -er '.monitors[] | select(.id | contains('$monitor_id')) | .status')
          if [[ "$monitor_status" == "OK" ]]; then
            break
          fi
          sleep 1
        done
        curl -s "https://api.datadoghq.com/api/v1/monitor/$monitor_id/unmute" \
          -XPOST \
          -H 'Content-Type: application/json' \
          -H "DD-API-KEY: $DATADOGAPIKEY" \
          -H "DD-APPLICATION-KEY: $__secret__DD_APP_KEY"

  muteEnvWideMonitors:
    # Parameters:
    #  - duration: mute duration in minutes. Optional, default 2880 (48h)
    - getVaultData
    - vaultSecretReadKeyB64:
        secretPath: "paas/customers/${globals.organizationName}/common/datadog"
        secretKey: "datadog_app_key"
    - cmd[${nodes.cp.first.id}]: |-
        __secret__DD_APP_KEY=$(echo -n "${globals.__secret__vaultSecretData}" | base64 -d)
        SCOPE_TAG="env-wide"
        monitors_id=($(curl -s "https://api.datadoghq.com/api/v1/monitor/search?query=tag%3A%22$SCOPE_TAG%22" -H "DD-APPLICATION-KEY: $__secret__DD_APP_KEY" -H "DD-API-KEY: $DATADOGAPIKEY" | jq '.monitors[] | .id'))
        MUTE_END=$(date -d "+${this.duration:2880}min" +%s)

        ENVNAME="${env.envName}"
        for monitor_id in "${monitors_id[@]}"; do
          curl -s "https://api.datadoghq.com/api/v1/monitor/$monitor_id/mute?scope=envname:$ENVNAME&end=$MUTE_END" -H "DD-APPLICATION-KEY: $__secret__DD_APP_KEY" -H "DD-API-KEY: $DATADOGAPIKEY" -XPOST
        done

  unmuteEnvWideMonitors:
    - getVaultData
    - vaultSecretReadKeyB64:
        secretPath: "paas/customers/${globals.organizationName}/common/datadog"
        secretKey: "datadog_app_key"
    - cmd[${nodes.cp.first.id}]: |-
        __secret__DD_APP_KEY=$(echo -n "${globals.__secret__vaultSecretData}" | base64 -d)
        SCOPE_TAG="env-wide"
        monitors_id=($(curl -s "https://api.datadoghq.com/api/v1/monitor/search?query=tag%3A%22$SCOPE_TAG%22" -H "DD-APPLICATION-KEY: $__secret__DD_APP_KEY" -H "DD-API-KEY: $DATADOGAPIKEY" | jq '.monitors[] | .id'))

        ENVNAME="${env.envName}"
        for monitor_id in "${monitors_id[@]}"; do
          curl -s "https://api.datadoghq.com/api/v1/monitor/$monitor_id/unmute?scope=envname:$ENVNAME" -H "DD-APPLICATION-KEY: $__secret__DD_APP_KEY" -H "DD-API-KEY: $DATADOGAPIKEY" -XPOST
        done
