---
actions:
  setGlobalRepoRootUrl:
    # Gets the repository root URL and set it in a global named "repoRootUrl", WITH NO TRAILING SLASH
    # Examples:
    #   repoRootUrl = https://github.com/Jahia/jelastic-packages/raw/master
    #   repoRootUrl = https://raw.githubusercontent.com/Jahia/jelastic-packages/master
    - if(!globals.repoRootUrl):
        - script: |-
            var baseUrl = "${baseUrl}"
            var regex = /https:\/\/(raw\.)?github\w*\.com\/Jahia\/[^\/]+\/(raw\/)?[^\/]+/
            var repoRootUrl = baseUrl.match(regex)
            return {"result": 0, "root_url": repoRootUrl[0]}
        - setGlobals:
            repoRootUrl: ${response.root_url}
    - else:
        log: "[INFO] global repoRootUrl is already defined with value '${globals.repoRootUrl}'"

  setSudoer:
    - log: "## Set sudoer on ${this}"
    - cmd[${this}]: |-
        touch /etc/sudoers.d/sudo
        # Warning : it only works if jelastic user exists, which may be compromised
        # if using a non-Jelastic docker image
        USER=$(id -nu $(id -u jelastic))
        echo "$USER ALL=NOPASSWD: ALL" >> /etc/sudoers.d/sudo
        echo "jelastic ALL=NOPASSWD: ALL" >> /etc/sudoers.d/sudo
      user: root
    - if ("${response.errOut}" != ""):
        - return:
            type: error
            message: "An error occurred during sudoers configuration."

  setJournaldLimit:
    - cmd[*]: |-
        sed -i 's/.*SystemMaxUse=.*/SystemMaxUse=200M/g' /etc/systemd/journald.conf
        systemctl restart systemd-journald.service
      user: root
    - if ("${response.errOut}" != ""):
        - return:
            type: error
            message: "An error occurred while configuring journald."

  setEnvVersion:
  # If the parameter is not an integer, we don't set the env version
    - if (/^[0-9]+$/.test(${this})):
        - script: |
            return api.env.nodegroup.ApplyData("${env.envName}", session, "cp", { envVersion: ${this} });
    - else:
        - log: "The parameter '${this}' is not an integer, nothing to do"


  checkEnvVersion:
    - script: |-
        const currentVersion = jelastic.env.control.GetNodeGroups("${env.envName}", session).object.filter(function (object) {
            return object.name == "cp";
        }).pop().envVersion;
        if (${this} <= currentVersion) {
            return {'result': 1, 'error': 'Environment is already up-to-date'}
        } else {
            return {'result': 0, 'out': 'Environment needs to be updated'}
        }

  getLogEventScript:
    - setGlobalRepoRootUrl
    - cmd[${this}]: |-
        curl -fLSso /usr/local/bin/log_event.sh ${globals.repoRootUrl}/assets/common/log_events.sh || exit 1
        chmod u+x /usr/local/bin/log_event.sh
      user: root

  logEvent:
    # Check if env is running (status = 1)
    if (1 == ${env.status}):
      cmd[${this.target}]: |-
        /usr/local/bin/log_event.sh "${this.title}" "${this.text}"
      user: root

  manageSystemdService:
    # Parameters:
    #   - target
    #   - unit
    #   - action
    - cmd[${this.target}]: systemctl ${this.action} ${this.unit}
      user: root


  ###################
  # COMPARE VERSION #
  ###################
  compareVersions:
    # Parameters :
    #  a : the first version to compare
    #  b : the second version to compare
    #  res : the global variable name to store the result
    # Returns:
    # 1 if a > b
    # 0 if a = b
    # -1 if a < b
    - script: |-
        function compare(index) {
          if (index > a.length)
            return 0;

          aDigit = parseInt(a[index]);
          bDigit = parseInt(b[index]);

          if (aDigit < bDigit)
            return -1;
          else if (aDigit > bDigit)
            return 1;
          else
            return compare(index+1)
        }

        const a = "${this.a}".split('.');
        const b = "${this.b}".split('.')

        if (a.length != b.length)
          return {"result": 1, "error": "invalid parameters"}

        return {"result": 0, "outcome": compare(0)}

    - setGlobals:
        versionIsGreater: 1
        versionIsEqual: 0
        versionIsLower: -1
        ${this.res}: ${response.outcome}

  isVersionStrictlyLower:
    # Parameters :
    #  a : the first version to compare
    #  b : the second version to compare
    #  res : the global variable name to store the result
    # Returns:
    # 1 if a < b
    # 0 if a >= b
    - compareVersions:
        a: "${this.a}"
        b: "${this.b}"
        res: isVersionStrictlyLowerComparison
    - if (${globals.isVersionStrictlyLowerComparison} == -1):
        setGlobals:
          ${this.res}: true
    - else:
        setGlobals:
          ${this.res}: false

  isVersionStrictlyHigher:
    # Parameters :
    #  a : the first version to compare
    #  b : the second version to compare
    #  res : the global variable name to store the result
    # Returns:
    # 1 if a > b
    # 0 if a <= b
    - compareVersions:
        a: "${this.a}"
        b: "${this.b}"
        res: isVersionStrictlyHigherComparison
    - if (${globals.isVersionStrictlyHigherComparison} == 1):
        setGlobals:
          ${this.res}: true
    - else:
        setGlobals:
          ${this.res}: false

  isVersionEqual:
    # Parameters :
    #  a : the first version to compare
    #  b : the second version to compare
    #  res : the global variable name to store the result
    # Returns:
    # 1 if a == b
    # 0 if a != b
    - compareVersions:
        a: "${this.a}"
        b: "${this.b}"
        res: isVersionEqualComparison
    - if (${globals.isVersionEqualComparison} == 0):
        setGlobals:
          ${this.res}: true
    - else:
        setGlobals:
          ${this.res}: false

  isVersionBetween:
    # Parameters :
    #  lower : the lower version to compare
    #  lower_may_equal : true is version can be equal to lower, false otherwise
    #  version : the version number to check
    #  higher : the higher version to compare
    #  higher_may_equal : true is version can be equal to higher, false otherwise
    #  res : the global variable name to store the result
    # Returns:
    # true if lower < version < higher and both *_may_equal are false
    # true if lower <= version <= higher and both *_may_equal are true
    # true if lower <= version < higher and only lower_may_equal is true
    # true if lower < version <= higher and only higher_may_equal is true
    # false otherwise
    - set:
        is_ok: false
    - compareVersions:
        a: "${this.lower}"
        b: "${this.higher}"
        res: areBoundsOK
    - if ( ${globals.areBoundsOK} <= 0):
        - compareVersions:
            a: "${this.lower}"
            b: "${this.version}"
            res: isLowerLower
        - compareVersions:
            a: "${this.version}"
            b: "${this.higher}"
            res: isHigherHigher
        - if (! ${this.lower_may_equal} && ! ${this.higher_may_equal}):
            - if (${globals.isLowerLower} == -1 && ${globals.isHigherHigher} == -1):
                - set:
                    is_ok: true
        - elif (${this.lower_may_equal} && ${this.higher_may_equal}):
            - if (${globals.isLowerLower} <= 0 && ${globals.isHigherHigher} <= 0):
                - set:
                    is_ok: true
        - elif (${this.lower_may_equal} && ! ${this.higher_may_equal}):
            - if (${globals.isLowerLower} <= 0 && ${globals.isHigherHigher} < 0):
                - set:
                    is_ok: true
        - elif (! ${this.lower_may_equal} && ${this.higher_may_equal}):
            - if (${globals.isLowerLower} < 0 && ${globals.isHigherHigher} <= 0):
                - set:
                    is_ok: true
    - else:
        - log: "[ERROR] Boundaries are not valid: '${this.lower}<=${this.higher}' is false"
        - return:
            type: error
            message: "Boundaries are not valid: '${this.lower}<=${this.higher}' is false"
    - if (${this.is_ok}):
        - setGlobals:
            ${this.res}: true
    - else:
        - setGlobals:
            ${this.res}: false

  isVersionLowerOrEqual:
    # Parameters :
    #  a : the first version to compare
    #  b : the second version to compare
    #  res : the global variable name to store the result
    # Returns:
    # 1 if a <= b
    # 0 if a > b
    - compareVersions:
        a: "${this.a}"
        b: "${this.b}"
        res: isVersionLowerOrEqualComparison
    - if (${globals.isVersionLowerOrEqualComparison} <= 0):
        setGlobals:
          ${this.res}: true
    - else:
        setGlobals:
          ${this.res}: false

  isVersionHigherOrEqual:
    # Parameters :
    #  a : the first version to compare
    #  b : the second version to compare
    #  res : the global variable name to store the result
    # Returns:
    # 1 if a >= b
    # 0 if a < b
    - compareVersions:
        a: "${this.a}"
        b: "${this.b}"
        res: isVersionHigherOrEqualComparison
    - if (${globals.isVersionHigherOrEqualComparison} >= 0):
        setGlobals:
          ${this.res}: true
    - else:
        setGlobals:
          ${this.res}: false

  installBackupTools:
    - setGlobalRepoRootUrl
    - cmd [${this.target}]: |-
        ## [${this.logAction}] - 1/5
        sudo python3 -m pip install --upgrade pip
        sudo python3 -m pip install --upgrade boto3 "azure==4.0.0" adal
        [ -d jelastic_backup ] || mkdir jelastic_backup
        cd jelastic_backup
        for file in backrest.py lib_aws.py lib_azure.py revisionNode.py; do
          curl -fLSso $file ${globals.repoRootUrl}/assets/common/$file || exit 1
        done
        curl -fLSso elasticsearch.py ${globals.repoRootUrl}/assets/elasticsearch/elasticsearch.py || exit 1

  clearJelasticLogs:
    - cmd[${this.target}]: echo "" > ${this.logsPath}; chown ${this.user}:root ${this.logsPath}
      user: root

  checkDatadogAgentCheck:
    # Parameters :
    #  - target: target node group or id
    #  - checkName: name of the Datadog agent check to check
    - cmd[${this.target}]: |-
        # "tail -n +2" is needed because the command outputs "=== JSON ===" before the JSON content...
        error_count=$(datadog-agent check ${this.checkName} --json | tail -n +2 | jq '.[].runner.TotalErrors')
        if [ $error_count -gt 0 ]; then
          echo "[ERROR] Datadog agent's '${this.checkName}' check failed" >&2
          exit 1
        fi
      user: root

  installRequiredPackages:
    # Parameters :
    #  - target: target node group or id
    #  - packages: name of the packages to install, space separated
    - setGlobalRepoRootUrl
    - cmd [${this.target}]: |-
        packages_to_install=()
        for package in ${this.packages}; do
          if ! rpm --quiet -q $package; then
            echo "$package needs to be installed"
            packages_to_install+=("$package")
          fi
        done
        [[ "${packages_to_install[@]}" == "" ]] || yum --setopt=tsflags=nodocs install -y ${packages_to_install[@]};
      user: root

  installPapiScript:
    - setGlobalRepoRootUrl
    - cmd [${this}]: |-
        python3 -m pip install --upgrade pip
        python3 -m pip install requests
        curl -fLSso /usr/local/bin/papi.py ${globals.repoRootUrl}/assets/common/papi.py || exit 1
        chmod 755 /usr/local/bin/papi.py
      user: root

  ###################
  # Vault actions   #
  ###################
  vaultAppRoleLogin:
    # Parameters:
    #   - this: target node group or id
    # Returns:
    #   ${globals.vaultToken}
    - set:
        generateNewToken: true
    - if ("${globals.vaultToken.print()}" != ""):
        - cmd [${this}}]: |-
            curl -s -H "X-Vault-Token: ${globals.vaultToken}" $VAULT_CLUSTER_URL/v1/auth/token/lookup-self \
              | jq -er .data &>/dev/null
            if [ $? -ne 0 ]; then
              echo "Token is not valid, it needs to be renewed"
            fi
        - if ("${response.out}" == ""):
            set:
              generateNewToken: false
    - if ("${this.generateNewToken}" == "true"):
        - cmd [${this}]: |-
            payloadfile=$(mktemp)
            cat > $payloadfile <<END
            {
              "role_id": "$VAULT_ROLE_ID",
              "secret_id": "$VAULT_SECRET_ID"
            }
            END
            VAULT_TOKEN=$(curl -s -XPOST $VAULT_CLUSTER_URL/v1/auth/approle/login --data @$payloadfile | jq -er .auth.client_token)
            rm -f $payloadfile
            if [ $? -ne 0 ]; then
              echo "[ERROR] Can't generate vault token with appRole login (VAULT_TOKEN=$VAULT_TOKEN)" >&2
              exit 1
            fi
            echo $VAULT_TOKEN
        - setGlobals:
            vaultToken: ${response.out}

  vaultSecretReadAllKeysB64:
    # Parameters:
    #   - target: target node group or id
    #   - secretPath: path (and name) of the secret to fetch
    # Returns:
    #   ${globals.vaultSecretData}: A JSON string with all key and data for the specified secret, base64 encoded
    - vaultAppRoleLogin: ${this.target}
    - cmd [${this.target}]: |-
        secret_data=$(mktemp)
        curl -s -H "X-Vault-Token: ${globals.vaultToken}" $VAULT_CLUSTER_URL/v1/kv/data/${this.secretPath} \
          | jq -cre ".data.data" \
          > $secret_data
        if [ $? -ne 0 ]; then
          echo "[ERROR] Can't read secret ${this.secretPath}" >&2
          cat $secret_data >&2
          rm -f $secret_data
          exit 1
        fi
        cat $secret_data | base64 -w 0
        rm -f $secret_data
    - setGlobals:
        vaultSecretData: ${response.out}

  vaultSecretReadKeyB64:
    # Parameters:
    #   - target: target node group or id
    #   - secretPath: path (and name) of the secret to fetch
    #   - secretKey: the secret's key
    # Returns:
    #   ${globals.vaultSecretData}: the specified secret's data, base64 encoded
    - vaultAppRoleLogin: ${this.target}
    - cmd [${this.target}]: |-
        secret_data=$(mktemp)
        curl -s -H "X-Vault-Token: ${globals.vaultToken}" $VAULT_CLUSTER_URL/v1/kv/data/${this.secretPath} \
          | jq -er ".data.data.\"${this.secretKey}\"" | tr -d '\n' | tr -d '\r' \
          > $secret_data
        if [ $? -ne 0 ]; then
          echo "[ERROR] Can't read secret ${this.secretPath}" >&2
          cat $secret_data >&2
          rm -f $secret_data
          exit 1
        fi
        cat $secret_data | base64 -w 0
        rm -f $secret_data
    - setGlobals:
        vaultSecretData: ${response.out}

  vaultSecretsList:
    # Parameters:
    #   - target: target node group or id
    #   - path: path to list
    #   - recursive: should be set to "true" if the secrets should be fetched
    #     recursively. Default: false
    # Returns:
    #   ${globals.vaultSecretsList}: the list of secrets/subpaths seperated by semicolons
    - vaultAppRoleLogin: ${this.target}
    - if ("${this.recursive.print()}" != "true"):
        set:
          recursive: false
    - cmd [${this.target}]: |-
        final_secrets_list=$(mktemp)
        tmp_secrets_list=$(mktemp)
        # Remove the last slash if any
        base_path=$(echo ${this.path} | sed "s;^\(.*\)/$;\1;")
        recursive=${this.recursive}

        # Recursive function to list secrets
        list_secrets_to_file() {
          local path=$1

          resp=$(curl -fsS -H "X-Vault-Token: ${globals.vaultToken}" -XLIST $VAULT_CLUSTER_URL/v1/kv/metadata/$path 2>&1)
          if [ $? -ne 0 ]; then
            echo "[ERROR] Can't list secrets at ${path}" >&2
            echo $resp >&2
            rm -f $tmp_secrets_list $final_secrets_list
            exit 1
          fi

          echo $resp | jq -cre '.data.keys | join("\n")' > $tmp_secrets_list
          cat $tmp_secrets_list | while read path_end; do
            full_path="$path/$path_end"
            # If recursive and "secret" ends with a slash, means it's a subpath
            #     We remove the trailing slash from the full path
            # else we just print the subpath with the trailing slash
            if [ "$recursive" = "true" ] && echo $path_end | grep -qE "/$"; then
                list_secrets_to_file $(echo -n $full_path | head -c -1)
            else
              echo $full_path >> $final_secrets_list
            fi
          done
          rm -f $tmp_secrets_list
        }

        list_secrets_to_file $base_path
        # We print all secrets semicolon separated, and without the base path
        cat $final_secrets_list | sed "s#$base_path/*##" | paste -s -d ';'
        rm -f $final_secrets_list
    - setGlobals:
        vaultSecretsList: ${response.out}

  vaultSecretDelete:
    # Parameters:
    #   - target: target node group or id
    #   - secretPath: path of the secret to delete
    - vaultAppRoleLogin: ${this.target}
    - cmd [${this.target}]: |-
        resp=$(curl -fs -H "X-Vault-Token: ${globals.vaultToken}" -XDELETE \
          $VAULT_CLUSTER_URL/v1/kv/metadata/${this.secretPath})
        if [ $? -ne 0 ]; then
          echo "[ERROR] Can't delete secret ${this.secretPath}" >&2
          echo $resp | jq -re .errors >&2
          exit 1
        fi

  removeAllSecrets:
    - vaultSecretsList:
        target: ${nodes.cp.first.id}
        path: "paas/customers/$ORGANIZATION_NAME/paas_${env.shortdomain}"
        recursive: "true"

    - script: |-
        return {"result": 0, "secrets": "${globals.vaultSecretsList}".split(";")}

    - forEach(response.secrets):
        vaultSecretDelete:
          target: ${nodes.cp.first.id}
          secretPath: "paas/customers/$ORGANIZATION_NAME/paas_${env.shortdomain}/${@i}"

  getBackrestAwsAccessKey:
    # Returns:
    #   ${globals.backrestAwsAccessKeyId}: Access key ID of backrest AWS user
    #   ${globals.backrestAwsSecretAccessKey}: Access secret key of backrest AWS user
    - vaultSecretReadAllKeysB64:
        target: ${nodes.cp.first.id}
        secretPath: "paas/envs-common/aws-backrest"
    - script: |-
        let vaultResponseBase64 = "${globals.vaultSecretData}";
        let vaultResponse = JSON.parse(java.lang.String(java.util.Base64.getDecoder().decode(vaultResponseBase64)))
        return {"result": 0, "access_key_id": vaultResponse.access_key_id, "secret_access_key": vaultResponse.secret_access_key}
    - setGlobals:
        backrestAwsAccessKeyId: '${response.access_key_id}'
        backrestAwsSecretAccessKey: '${response.secret_access_key}'

  muteDatadogHost:
    # Parameters:
    #  - target: target node group or id
    #  - duration: mute duration in minutes. Optional, default 60
    - vaultSecretReadKeyB64:
        target: ${nodes.cp.first.id}
        secretPath: "paas/customers/$ORGANIZATION_NAME/common/datadog"
        secretKey: "datadog_app_key"
    - cmd[${this.target}]: |-
        DD_HOSTNAME=$(awk '$1=="hostname:" {print $2}' /etc/datadog-agent/datadog.yaml)
        DD_APP_KEY=$(echo -n "${globals.vaultSecretData}" | base64 -d)

        MUTE_END=$(date -d "+${this.duration:60}min" +%s)

        curl "https://api.datadoghq.com/api/v1/host/$DD_HOSTNAME/mute" \
          -XPOST \
          -H 'Content-Type: application/json' \
          -H "DD-API-KEY: $DATADOGAPIKEY" \
          -H "DD-APPLICATION-KEY: $DD_APP_KEY"  \
          -d "{\"end\": $MUTE_END, \"action\":\"Muted\", \"override\": \"true\"}"

      user: root

  unmuteDatadogHost:
    # Parameters:
    #  - target: target node group or id
    - vaultSecretReadKeyB64:
        target: ${nodes.cp.first.id}
        secretPath: "paas/customers/$ORGANIZATION_NAME/common/datadog"
        secretKey: "datadog_app_key"
    - cmd[${this.target}]: |-
        DD_HOSTNAME=$(awk '$1=="hostname:" {print $2}' /etc/datadog-agent/datadog.yaml)
        DD_APP_KEY=$(echo -n "${globals.vaultSecretData}" | base64 -d)

        curl "https://api.datadoghq.com/api/v1/host/$DD_HOSTNAME/unmute" \
          -XPOST \
          -H "DD-API-KEY: $DATADOGAPIKEY" \
          -H "DD-APPLICATION-KEY: $DD_APP_KEY"
      user: root


  getPapiToken:
    - vaultSecretReadKeyB64:
        target: ${nodes.cp.first.id}
        secretPath: "paas/customers/$ORGANIZATION_NAME/paas_${env.envName}/papi"
        secretKey: "token"
    - setGlobals:
        papiToken: '${globals.vaultSecretData.fromBase64()}'

  updateEnvStatusInPapi:
    # Parameters:
    #  - status: stopped, running, creating
    - if ("${globals.papiToken.print()}" == ""):
        getPapiToken
    - cmd[${nodes.cp.first.id}]: |-
        export PAPI_TOKEN="${globals.papiToken}"
        papi.py -X PUT -d '{"status": "${this.status}"}' paas-environment/$PAPI_ENV_ID


  updateProductVersionInPapi:
    # Parameters:
    #  - product: dx, unomi
    #  - version: product verion
    - if ("${globals.papiToken.print()}" == ""):
        getPapiToken
    - cmd[${nodes.cp.first.id}]: |-
        export PAPI_TOKEN="${globals.papiToken}"
        version=$(echo "${this.product}_${this.version}" | tr -s '.' '-')
        papi.py -X PUT -d "{\"paas_product_version_id\": \"$version\"}" paas-environment/$PAPI_ENV_ID

  setEnvironmentAppId:
    - if ("${globals.papiToken.print()}" == ""):
        getPapiToken
    - cmd[${nodes.cp.first.id}]: |-
        export PAPI_TOKEN="${globals.papiToken}"
        papi.py -X PUT -d '{"jelastic_appid": "${env.appid}"}' paas-environment/$PAPI_ENV_ID

  deleteEnvironment:
    - if ("${globals.papiToken.print()}" == ""):
        - getPapiToken
    - cmd[${nodes.cp.first.id}]: |-
        export PAPI_TOKEN="${globals.papiToken}"
        papier_id=$(papi.py -X GET paas-environment/$PAPI_ENV_ID | jq -r .papier_id)
        papi.py -X DELETE paas-environment/$PAPI_ENV_ID
        papi.py -X DELETE papier/$papier_id
