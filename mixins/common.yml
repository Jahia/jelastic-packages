---
actions:
  setGlobalRepoRootUrl:
    # Gets the repository root URL and set it in a global named "repoRootUrl", WITH NO TRAILING SLASH
    # Examples:
    #   repoRootUrl = https://github.com/Jahia/jelastic-packages/raw/main
    #   repoRootUrl = https://raw.githubusercontent.com/Jahia/jelastic-packages/main
    #   repoRootUrl = https://raw.githubusercontent.com/Jahia/jelastic-packages/refs/heads/main
    - if(!globals.repoRootUrl):
        - script: |-
            var baseUrl = "${baseUrl}"
            var regex = /https:\/\/(raw\.)?github\w*\.com\/Jahia\/[^\/]+\/(raw\/)?(refs\/(heads|tags)\/)?[^\/]+/
            var repoRootUrl = baseUrl.match(regex)
            return {"result": 0, "root_url": repoRootUrl[0]}
        - setGlobals:
            repoRootUrl: ${response.root_url}
    - else:
        log: "[INFO] global repoRootUrl is already defined with value '${globals.repoRootUrl}'"

  setJelasticUserAsRoot:
    - setGlobalRepoRootUrl
    - log: "## Set Jelastic user as root on ${this}"
    - cmd [${this}]: sed -i 's;^jelastic:.*;jelastic:x:0:0::/root:/bin/bash;' /etc/passwd
      user: root
    - cmd [${this}]: curl --retry 6 -fLSso /etc/sudoers.d/jahia-rules ${globals.repoRootUrl}/assets/common/sudoers-file || exit 1

  setJournaldLimit:
    - cmd[*]: |-
        sed -i 's/.*SystemMaxUse=.*/SystemMaxUse=200M/g' /etc/systemd/journald.conf
        systemctl restart systemd-journald.service
    - if ("${response.errOut}" != ""):
        - return:
            type: error
            message: "An error occurred while configuring journald."

  checkIfEnvExists:
    # Set the global check_env_exists to true if the env exists, false otherwise
    # parameters:
    #  - envName
    script: |-
      response = jelastic.env.control.GetEnvInfo("${this.envName}", session);
      res = {"result": 0}
      res.onAfterReturn = {
        setGlobals: {
          check_env_exists: response.result == 0
        }
      }
      return res

  setEnvVersion:
  # If the parameter is not an integer, we don't set the env version
    - if (/^[0-9]+$/.test(${this})):
        - script: |
            return api.env.nodegroup.ApplyData("${env.envName}", session, "cp", { envVersion: ${this} });
    - else:
        - log: "The parameter '${this}' is not an integer, nothing to do"

  getEnvVersion:
    - script: |-
        const envVersion = jelastic.env.control.GetNodeGroups("${env.envName}", session).object.filter(function (object) {
            return object.name == "cp";
        }).pop().envVersion;
        return {'result': 0, 'envVersion': envVersion}
    - setGlobals:
        envVersion: ${response.envVersion}

  checkEnvVersion:
    - script: |-
        const currentVersion = jelastic.env.control.GetNodeGroups("${env.envName}", session).object.filter(function (object) {
            return object.name == "cp";
        }).pop().envVersion;
        if (${this} <= currentVersion) {
            return {'result': 1, 'error': 'Environment is already up-to-date'}
        } else {
            return {'result': 0, 'out': 'Environment needs to be updated'}
        }

  getLogEventScript:
    - setGlobalRepoRootUrl
    - cmd[${this}]: |-
        curl --retry 6 -fLSso /usr/local/bin/log_event.sh ${globals.repoRootUrl}/assets/common/log_events.sh || exit 1
        chmod u+x /usr/local/bin/log_event.sh
      user: root

  logEvent:
    # Check if env is running (status = 1)
    if (1 == ${env.status}):
      cmd[${this.target}]: |-
        /usr/local/bin/log_event.sh "${this.title}" "${this.text}"
      user: root

  manageSystemdService:
    # Parameters:
    #   - target
    #   - unit
    #   - action
    - cmd[${this.target}]: systemctl ${this.action} ${this.unit}

  setCloudConf:
    # Grab dev/preprod/prod infrastructure conf file
    # and create "cloud_conf" nodegroup data from it on cp
    - setGlobalRepoRootUrl
    - cmd[${nodes.cp.first.id}]: |-
        metadata_file="/metadata_from_HOST"
        timeout=$((SECONDS+120))
        while [ $SECONDS -lt $timeout ]; do
          if [ -s $metadata_file ]; then
            eval $(grep "^JEL_ENV_ROLE=" /metadata_from_HOST)
            file="${JEL_ENV_ROLE}.conf.json"
            r=$(curl --retry 6 -LsSo /tmp/$file -w '%{http_code}' ${globals.repoRootUrl}/conf/$file)
            if [ $r -eq 200 ]; then
              cat /tmp/$file && rm -f /tmp/$file
              exit 0
            else
              echo "Error on ${globals.repoRootUrl}/conf/$file download, return code: $r" 1>&2
              exit 1
            fi
          fi
          sleep 0.5
        done
        echo "$metadata_file doesn't exist or has a size of 0 byte." 1>&2
        exit 2
    - api: env.control.ApplyNodeGroupData
      nodeGroup: cp
      data: ${response.out.toJSON()}

  getCloudConf:
    # Grab cp's nodegroup data "cloud_conf"
    # and export globals.cloud_conf
    - script: |-
        conf = jelastic.env.control.getnodegroups('${env.envName}', session).object.filter(function (object) {
                 return object.name == "cp"}).pop().cloud_conf
        if (conf == null) {
          return {"result": 1, "error": "Can't found 'cloud_conf' in nodegroup data"}
        } else {
          setglobals = {setGlobals: {cloud_conf: conf}}
          return {"result": 0, onAfterReturn: setglobals}
        }

  ###################
  # COMPARE VERSION #
  ###################
  compareVersions:
    # Parameters :
    #  a : the first version to compare
    #  b : the second version to compare
    #  res : the global variable name to store the result
    # Returns:
    # 1 if a > b
    # 0 if a = b
    # -1 if a < b
    - script: |-
        function compare(index) {
          if (index > a.length)
            return 0;

          aDigit = parseInt(a[index]);
          bDigit = parseInt(b[index]);

          if (aDigit < bDigit)
            return -1;
          else if (aDigit > bDigit)
            return 1;
          else
            return compare(index+1)
        }

        const a = "${this.a}".split('.');
        const b = "${this.b}".split('.')

        if (a.length != b.length)
          return {"result": 1, "error": "invalid parameters"}

        return {"result": 0, "outcome": compare(0)}

    - setGlobals:
        versionIsGreater: 1
        versionIsEqual: 0
        versionIsLower: -1
        ${this.res}: ${response.outcome}

  isVersionStrictlyLower:
    # Parameters :
    #  a : the first version to compare
    #  b : the second version to compare
    #  res : the global variable name to store the result
    # Returns:
    # 1 if a < b
    # 0 if a >= b
    - compareVersions:
        a: "${this.a}"
        b: "${this.b}"
        res: isVersionStrictlyLowerComparison
    - if (${globals.isVersionStrictlyLowerComparison} == -1):
        setGlobals:
          ${this.res}: true
    - else:
        setGlobals:
          ${this.res}: false

  isVersionStrictlyHigher:
    # Parameters :
    #  a : the first version to compare
    #  b : the second version to compare
    #  res : the global variable name to store the result
    # Returns:
    # 1 if a > b
    # 0 if a <= b
    - compareVersions:
        a: "${this.a}"
        b: "${this.b}"
        res: isVersionStrictlyHigherComparison
    - if (${globals.isVersionStrictlyHigherComparison} == 1):
        setGlobals:
          ${this.res}: true
    - else:
        setGlobals:
          ${this.res}: false

  isVersionEqual:
    # Parameters :
    #  a : the first version to compare
    #  b : the second version to compare
    #  res : the global variable name to store the result
    # Returns:
    # 1 if a == b
    # 0 if a != b
    - compareVersions:
        a: "${this.a}"
        b: "${this.b}"
        res: isVersionEqualComparison
    - if (${globals.isVersionEqualComparison} == 0):
        setGlobals:
          ${this.res}: true
    - else:
        setGlobals:
          ${this.res}: false

  isVersionBetween:
    # Parameters :
    #  lower : the lower version to compare
    #  lower_may_equal : true is version can be equal to lower, false otherwise
    #  version : the version number to check
    #  higher : the higher version to compare
    #  higher_may_equal : true is version can be equal to higher, false otherwise
    #  res : the global variable name to store the result
    # Returns:
    # true if lower < version < higher and both *_may_equal are false
    # true if lower <= version <= higher and both *_may_equal are true
    # true if lower <= version < higher and only lower_may_equal is true
    # true if lower < version <= higher and only higher_may_equal is true
    # false otherwise
    - set:
        is_ok: false
    - compareVersions:
        a: "${this.lower}"
        b: "${this.higher}"
        res: areBoundsOK
    - if ( ${globals.areBoundsOK} <= 0):
        - compareVersions:
            a: "${this.lower}"
            b: "${this.version}"
            res: isLowerLower
        - compareVersions:
            a: "${this.version}"
            b: "${this.higher}"
            res: isHigherHigher
        - if (! ${this.lower_may_equal} && ! ${this.higher_may_equal}):
            - if (${globals.isLowerLower} == -1 && ${globals.isHigherHigher} == -1):
                - set:
                    is_ok: true
        - elif (${this.lower_may_equal} && ${this.higher_may_equal}):
            - if (${globals.isLowerLower} <= 0 && ${globals.isHigherHigher} <= 0):
                - set:
                    is_ok: true
        - elif (${this.lower_may_equal} && ! ${this.higher_may_equal}):
            - if (${globals.isLowerLower} <= 0 && ${globals.isHigherHigher} < 0):
                - set:
                    is_ok: true
        - elif (! ${this.lower_may_equal} && ${this.higher_may_equal}):
            - if (${globals.isLowerLower} < 0 && ${globals.isHigherHigher} <= 0):
                - set:
                    is_ok: true
    - else:
        - log: "[ERROR] Boundaries are not valid: '${this.lower}<=${this.higher}' is false"
        - return:
            type: error
            message: "Boundaries are not valid: '${this.lower}<=${this.higher}' is false"
    - if (${this.is_ok}):
        - setGlobals:
            ${this.res}: true
    - else:
        - setGlobals:
            ${this.res}: false

  isVersionLowerOrEqual:
    # Parameters :
    #  a : the first version to compare
    #  b : the second version to compare
    #  res : the global variable name to store the result
    # Returns:
    # 1 if a <= b
    # 0 if a > b
    - compareVersions:
        a: "${this.a}"
        b: "${this.b}"
        res: isVersionLowerOrEqualComparison
    - if (${globals.isVersionLowerOrEqualComparison} <= 0):
        setGlobals:
          ${this.res}: true
    - else:
        setGlobals:
          ${this.res}: false

  isVersionHigherOrEqual:
    # Parameters :
    #  a : the first version to compare
    #  b : the second version to compare
    #  res : the global variable name to store the result
    # Returns:
    # 1 if a >= b
    # 0 if a < b
    - compareVersions:
        a: "${this.a}"
        b: "${this.b}"
        res: isVersionHigherOrEqualComparison
    - if (${globals.isVersionHigherOrEqualComparison} >= 0):
        setGlobals:
          ${this.res}: true
    - else:
        setGlobals:
          ${this.res}: false

  installBackupTools:
    - setGlobalRepoRootUrl
    - cmd [${this.target}]: |-
        [ -d jelastic_backup ] || mkdir jelastic_backup
        cd jelastic_backup
        for file in backrest.py lib_aws.py revisionNode.py; do
          curl -fLSso $file ${globals.repoRootUrl}/assets/common/$file || exit 1
        done
        curl -fLSso elasticsearch.py ${globals.repoRootUrl}/assets/elasticsearch/elasticsearch.py || exit 1

  clearJelasticLogs:
    - cmd[${this.target}]: echo "" > ${this.logsPath}; chown ${this.user}:root ${this.logsPath}

  checkDatadogAgentCheck:
    # Parameters :
    #  - target: target node group or id
    #  - checkName: name of the Datadog agent check to check
    - cmd[${this.target}]: |-
        check_response=$(datadog-agent check ${this.checkName} --json)
        total_errors=$(echo $check_response | jq '.[].runner.TotalErrors')
        monitors_in_error=$(echo $check_response | jq '.[0].aggregator.service_checks[] | select (.status != 0) | .check')
        # Make sure total errors is an integer and equals 0, and that the check is not in error
        if ! [[ $(echo "$total_errors" | grep "^[0-9]*$") ]] || [ $total_errors -gt 0 ] || [ "$monitors_in_error" != "" ]; then
          echo "[ERROR] Datadog agent's '${this.checkName}' check failed" >&2
          exit 1
        fi
  configureDatadogSite:
    # Parameters :
    #  - target: target nodegroup or nodeid
  - if ("HideThisLine" && "${globals.__secret__papiToken.print()}" == ""):
      getPapiInfoAll
  - installPapiScript: ${nodes.cp.first.id}
  - cmd [${nodes.cp.first.id}]: |-
      set -e
      __secret__PAPI_TOKEN="${globals.__secret__papiToken}"
      export PAPI_TOKEN="$__secret__PAPI_TOKEN"
      export PAPI_HOSTNAME="${globals.papiHostname}"
      export PAPI_ENV_ID="${globals.papiEnvId}"
      export PAPI_API_VERSION="${globals.papiApiVersion}"
      organization_id=$(papi.py -X GET paas-environment/$PAPI_ENV_ID | jq -r '.paas_organization_id')
      organization=$(papi.py -X GET paas-organization/$organization_id)
      dd_site=$(echo $organization | jq -r '.datadog_site')
      [ "$dd_site" = "null" ] && exit 1
      echo $dd_site
  - env.control.AddContainerEnvVars [${this.target}]:
    vars:
      DD_SITE: ${response.out}

  installLatestDatadogAgent:
    - cmd[${this}]: |-
        source /etc/profile
        dd_agent_override_dir=/etc/systemd/system/datadog-agent.service.d
        dd_agent_override_file=$dd_agent_override_dir/override.conf
        export DD_API_KEY=$DATADOGAPIKEY
        export DD_INSTALL_ONLY=true
        bash -c "$(curl -L https://s3.amazonaws.com/dd-agent/scripts/install_script_agent7.sh)" || exit 1
        mkdir -p $dd_agent_override_dir
        chmod 755 $dd_agent_override_dir
        echo -e "[Service]\nEnvironmentFile=-/.jelenv" > $dd_agent_override_file
        chmod 644 $dd_agent_override_file
        systemctl daemon-reload
    - configureDatadogSite:
        target: ${this}

  installRequiredPackages:
    # Parameters :
    #  - target: target node group or id
    #  - packages: name of the packages to install, space separated
    - setGlobalRepoRootUrl
    - cmd [${this.target}]: |-
        packages_to_install=()
        for package in ${this.packages}; do
          if ! rpm --quiet -q $package; then
            echo "$package needs to be installed"
            packages_to_install+=("$package")
          fi
        done
        [[ "${packages_to_install[@]}" == "" ]] || yum --setopt=tsflags=nodocs install -y ${packages_to_install[@]};

  installPapiScript:
    - setGlobalRepoRootUrl
    - cmd [${this}]: |-
        if [ ! -f /usr/local/bin/papi.py ]; then
          yum -y install python3-requests
          curl --retry 6 -fLSso /usr/local/bin/papi.py ${globals.repoRootUrl}/assets/common/papi.py || exit 1
          chmod 755 /usr/local/bin/papi.py
        fi
      user: root

  ###################
  # Vault actions   #
  ###################
  vaultAppRoleLogin:
    # Returns:
    #   ${globals.__secret__vaultToken}
    - set:
        generateNewToken: true
    - script: |
        import org.apache.http.client.methods.HttpGet;
        import org.apache.http.impl.client.HttpClients;
        __secret__vaultToken = "${globals.__secret__vaultToken}";
        httpGet = new HttpGet("${globals.vaultClusterUrl}/v1/auth/token/lookup-self");
        httpGet.setHeader("X-Vault-Token", __secret__vaultToken);
        httpClient = HttpClients.createDefault();
        resp = httpClient.execute(httpGet).getStatusLine().getStatusCode();
        if (resp != 200) {
          return {"result": 0, out: "Token is not valid, it needs to be renewed" };
        }
          return {"result": 0, out: ""};
    - if ("${response.out}" == ""):
        set:
          generateNewToken: false
    - if ("${this.generateNewToken}" == "true"):
        - script: |
            import org.apache.http.client.methods.HttpPost;
            import org.apache.http.impl.client.HttpClients;
            import org.apache.http.util.EntityUtils;
            import org.apache.http.entity.StringEntity;
            __secret__vaultRoleId = "${globals.__secret__vaultRoleId}";
            __secret__vaultSecretId = "${globals.__secret__vaultSecretId}";
            httpPost = new HttpPost("${globals.vaultClusterUrl}/v1/auth/approle/login");
            json = toJSON({
                  "role_id": __secret__vaultRoleId,
                  "secret_id": __secret__vaultSecretId
                  }
             );
            stringEntity = new StringEntity(json);
            httpPost.setEntity(stringEntity);
            httpClient = HttpClients.createDefault();
            resp = httpClient.execute(httpPost);
            if (resp.getStatusLine().getStatusCode() != 200) {
              return {"result": 1, errOut: "Can't generate vault token with appRole login" };
            }
            data = JSON.parse(EntityUtils.toString(resp.getEntity()));
            vaultToken = data["auth"]["client_token"];
            return {
              "result": 0,
              "onAfterReturn": {
                setGlobals: {
                  "__secret__vaultToken": vaultToken
                }
              }
            };

  vaultSecretExists:
    # Check if a secret exists. It must be in an authorized path for the env token, otherwise it will fail and exit
    # Parameters:
    #   - secretPath: path (and name) of the secret to check
    # Returns:
    #   ${globals.secretExists}: A boolean set to true if the secret exists. Set to false otherwise
    - vaultAppRoleLogin
    - script: |
        import org.apache.http.client.methods.HttpGet;
        import org.apache.http.impl.client.HttpClients;
        import org.apache.http.util.EntityUtils;
        import java.util.Base64;
        __secret__vaultToken = "${globals.__secret__vaultToken}";
        httpGet = new HttpGet("${globals.vaultClusterUrl}/v1/kv/data/${this.secretPath}");
        httpGet.setHeader("X-Vault-Token", __secret__vaultToken);
        httpClient = HttpClients.createDefault();
        resp = httpClient.execute(httpGet);
        statusCode = resp.getStatusLine().getStatusCode();
        if (statusCode == 200 ) {
          return {"result": 0, "message": "Secret exists", "secretExists": true};
        } else if (statusCode == 404 ) {
          return {"result": 0, "message": "Secret does not exist", "secretExists": false};
        } else {
          return {"result": 1, "message": "Error: " + resp};
        }
    - setGlobals:
        secretExists: ${response.secretExists}

  vaultSecretReadAllKeysB64:
    # Parameters:
    #   - secretPath: path (and name) of the secret to fetch
    # Returns:
    #   ${globals.__secret__vaultSecretData}: A JSON string with all key and data for the specified secret, base64 encoded
    - vaultAppRoleLogin
    - script: |
        import org.apache.http.client.methods.HttpGet;
        import org.apache.http.impl.client.HttpClients;
        import org.apache.http.util.EntityUtils;
        import java.util.Base64;
        __secret__vaultToken = "${globals.__secret__vaultToken}";
        httpGet = new HttpGet("${globals.vaultClusterUrl}/v1/kv/data/${this.secretPath}");
        httpGet.setHeader("X-Vault-Token", __secret__vaultToken);
        httpClient = HttpClients.createDefault();
        resp = httpClient.execute(httpGet);
        if (resp.getStatusLine().getStatusCode() != 200) {
          return {"result": 1, errOut: "Can't read secret ${this.secretPath}" };
        }
        data = JSON.parse(EntityUtils.toString(resp.getEntity()));
        secrets = java.lang.String(data["data"]["data"]);
        secretsB64 = Base64.getEncoder().encodeToString(secrets.getBytes());
        return {
          "result": 0,
          "onAfterReturn": {
            setGlobals: {
              "__secret__vaultSecretData": secretsB64
            }
          }
        };

  vaultSecretReadKeyB64:
    # Parameters:
    #   - secretPath: path (and name) of the secret to fetch
    #   - secretKey: the secret's key
    # Returns:
    #   ${globals.__secret__vaultSecretData}: the specified secret's data, base64 encoded
    - vaultAppRoleLogin
    - script: |
        import org.apache.http.client.methods.HttpGet;
        import org.apache.http.impl.client.HttpClients;
        import org.apache.http.util.EntityUtils;
        import java.util.Base64;
        __secret__vaultToken = "${globals.__secret__vaultToken}";
        httpGet = new HttpGet("${globals.vaultClusterUrl}/v1/kv/data/${this.secretPath}");
        httpGet.setHeader("X-Vault-Token", __secret__vaultToken);
        httpClient = HttpClients.createDefault();
        resp = httpClient.execute(httpGet);
        if (resp.getStatusLine().getStatusCode() != 200) {
          return {"result": 1, errOut: "Can't read secret ${this.secretPath}" };
        }
        data = JSON.parse(EntityUtils.toString(resp.getEntity()));
        secret = java.lang.String(data["data"]["data"]["${this.secretKey}"]);
        secretB64 = Base64.getEncoder().encodeToString(secret.getBytes());
        return {
          "result": 0,
          "onAfterReturn": {
            setGlobals: {
              "__secret__vaultSecretData": secretB64
            }
          }
        };

  vaultSecretSet:
    # Parameters:
    #   - secretPath: path (and name) of the secret to set
    #   - __secret__secretData: the secret's data ex: {"foo": "bar","zip": "zap"}
    - vaultAppRoleLogin
    - script: |
        import org.apache.http.client.methods.HttpPost;
        import org.apache.http.impl.client.HttpClients;
        import org.apache.http.util.EntityUtils;
        import org.apache.http.entity.StringEntity;
        __secret__secretData = ${this.__secret__secretData};
        __secret__vaultToken = "${globals.__secret__vaultToken}";
        secretPath = "${this.secretPath}";

        httpPost = new HttpPost("${globals.vaultClusterUrl}/v1/kv/data/" + secretPath);
        httpPost.setHeader("X-Vault-Token", __secret__vaultToken);
        json = toJSON({"data": __secret__secretData});
        stringEntity = new StringEntity(json);
        httpPost.setEntity(stringEntity);
        httpClient = HttpClients.createDefault();
        resp = httpClient.execute(httpPost);
        if (resp.getStatusLine().getStatusCode() != 200) {
          return {"result": 1, errOut: "Can't update/create secret " + secretPath + ". " + resp };
        }

        return {"result": 0}

  vaultSecretDelete:
    # Parameters:
    #   - secretPath: path of the secret to delete
    - vaultAppRoleLogin
    - script: |
        import org.apache.http.client.methods.HttpDelete;
        import org.apache.http.client.methods.HttpGet;
        import org.apache.http.impl.client.HttpClients;
        import org.apache.http.util.EntityUtils;
        __secret__vaultToken = "${globals.__secret__vaultToken}";
        secretDelete = new HttpDelete("${globals.vaultClusterUrl}/v1/kv/metadata/${this.secretPath}");
        secretDelete.setHeader("X-Vault-Token", __secret__vaultToken);
        httpClient = HttpClients.createDefault();
        resp = httpClient.execute(secretDelete);
        if (resp.getStatusLine().getStatusCode() != 204) {
          return {"result": 1, errOut: "Can't delete secret from ${this.secretPath}" };
        }
        return {"result": 0, out: "Secret has been deleted"};

  removeAllSecrets:
    - getVaultData
    - setGlobals:
        vaultSecretsList: papi;haproxy;ipsec/conn-1;PAT/root

    - script: |-
        return {"result": 0, "secrets": "${globals.vaultSecretsList}".split(";")}

    - forEach(response.secrets):
        vaultSecretDelete:
          secretPath: "paas/customers/${globals.organizationName}/paas_${env.shortdomain}/${@i}"

  createFileFromVaultSecretKey:
    # Parameters:
    #   - target: node id or nodegroup name to put the file on
    #   - secretPath: path (and name) of the secret to fetch
    #   - destFullPath: full path of the file to create on the node (path have to exist)
    #   - (optional) owner: owner of the file on the node (default to root)
    #   - (optional) group: owner group of the file on the node (default to root)
    #   - (optional) mode: permissions the file on the node (default to 0640)
    #
    # We are not using other Jelastic actions to fetch the content from Vault because it doesn't work when
    # the secret data is too big (Jelastic cannot create the global variable and therefore it fails)
    #####################
    - getVaultData
    - cmd [${this.target}]: |-
        __secret__vaultRoleId="${globals.__secret__vaultRoleId}"
        __secret__vaultSecretId="${globals.__secret__vaultSecretId}"
        VAULT_TOKEN=$(curl -s -XPOST ${globals.vaultClusterUrl}/v1/auth/approle/login --data '{"role_id": "'"$__secret__vaultRoleId"'", "secret_id": "'"$__secret__vaultSecretId"'"}' | jq -er .auth.client_token)
        if [ $? -ne 0 ]; then
          echo "Vault authentication failed" >&2
          exit 0
        fi

        secret_path="$(dirname ${this.secretPath})"
        key_name="$(basename ${this.secretPath})"

        # check if secret exist
        response=$(curl -s -H "X-Vault-Token: $VAULT_TOKEN" ${globals.vaultClusterUrl}/v1/kv/data/${secret_path})
        if [ $? -ne 0 ]; then
          echo "Failed to fetch secret" >&2
          exit 0
        fi
        # check if the file's key exist in the response
        content="$(jq -e .data.data <<< "$response")"
        if ! (jq 'keys[]' <<< "$content" | grep -q "$key_name"); then
          echo "There is no '$key_name' key in $(dirname $secret_path) secret" >&2
          exit 0
        fi

        # create the temp file
        temp_file=$(mktemp)
        jq -r '."'${key_name}'"' <<< "$content" > $temp_file

        # set owner/group
        chown ${this.owner:root}:${this.group:root} $temp_file

        # change permissions if needed
        chmod ${this.mode:0640} $temp_file

        # move file to final destination
        mv $temp_file ${this.destFullPath}

    - if ("${response.errOut}" != ""):
        - return:
            type: error
            message: "Failed to create a file from a Vault's secret key, error: ${response.errOut}"

  getBackrestAwsAccessKey:
    # Returns:
    #   ${globals.__secret__backrestAwsAccessKeyId}: Access key ID of backrest AWS user
    #   ${globals.__secret__backrestAwsSecretAccessKey}: Access secret key of backrest AWS user
    - getVaultData
    - vaultSecretReadAllKeysB64:
        secretPath: "paas/envs-common/aws-backrest"
    - script: |-
        let __secret__vaultResponseBase64 = "${globals.__secret__vaultSecretData}";
        let vaultResponse = JSON.parse(java.lang.String(java.util.Base64.getDecoder().decode(__secret__vaultResponseBase64)))
        return {
          "result": 0,
          "onAfterReturn": {
            setGlobals: {
              "__secret__backrestAwsAccessKeyId": vaultResponse.access_key_id,
              "__secret__backrestAwsSecretAccessKey": vaultResponse.secret_access_key
            }
          }
        };

  getOvhBackupCredentials:
    # Returns:
    #   ${globals.__secret__backupAccessKeyId}: Access key ID of backup OVH user
    #   ${globals.__secret__backupSecretAccessKey}: Access secret key of backup OVH user
    - getVaultData
    - vaultSecretReadAllKeysB64:
        secretPath: "paas/envs-common/ovh-backup"
    - script: |-
        let __secret__vaultResponseBase64 = "${globals.__secret__vaultSecretData}";
        let vaultResponse = JSON.parse(java.lang.String(java.util.Base64.getDecoder().decode(__secret__vaultResponseBase64)))
        return {
          "result": 0,
          "onAfterReturn": {
            setGlobals: {
              "__secret__backupAccessKeyId": vaultResponse.access_key_id,
              "__secret__backupSecretAccessKey": vaultResponse.secret_access_key
            }
          }
        };

  setupBackupRCloneConfig:
    # Parameters
    # provider: the cloud provider hosting the s3 bucket
    # region: the region of the s3 bucket
    - cmd[*]: |-
        provider=${this.provider}
        region=${this.region}
        if [ "$provider" = "ovh" ]; then
          # OVH hns are on rbx or gra so we force gra region to backup in case the node is in Roubaix
          region="gra"
          provider="Other"
          endpoint="https://s3.$region.io.cloud.ovh.net/"
        else
          endpoint=""
          provider=AWS
        fi

        rclone_conf=/root/.config/rclone/rclone.conf
        # Sed commands only changes patterns after the [backup] section
        sed -i -r "/\[backup\]/,// s|endpoint =.*|endpoint = $endpoint|" $rclone_conf
        sed -i -r "/\[backup\]/,// s|provider =.*|provider = $provider|" $rclone_conf
        sed -i -r "/\[backup\]/,// s|region =.*|region = $region|" $rclone_conf
        sed -i -r "/\[backup\]/,// s|location_constraint =.*|location_constraint = $location_constraint|" $rclone_conf

  getBucketName:
    # Parameters:
    #  - region: the region hosting the env
    #  - uid: the jelastic account uid
    #  - clusterRole: the env  role
    #  - cloudProvider: the cloudprovider hosting the env
    # Returns:
    #  - ${globals.bucketName}: the name of the bucket
    - cmd[${nodes.cp.first.id}]: |-
        if [ "${globals.oldOvhRegion:false}" == "true" ]; then
          # legacy bucket name for ovh region
          region="gra2"
        elif [ "${this.cloudProvider}" == "ovh" ]; then
          # Force the backup region for ovh
          region="gra"
        else
          region=$(echo "${this.region}" | sed 's/[[:punct:]]//g')
        fi
        bucket_name="jc${this.clusterRole}${this.uid}$region"
        echo $bucket_name
    - setGlobals:
        bucketName: ${response.out}

  muteDatadogHost:
    # Parameters:
    #  - target: target node group or id
    #  - duration: mute duration in minutes. Optional, default 60
    - getVaultData
    - vaultSecretReadKeyB64:
        secretPath: "paas/customers/${globals.organizationName}/common/datadog"
        secretKey: "datadog_app_key"
    - cmd[${this.target}]: |-
        DD_HOSTNAME=$(awk '$1=="hostname:" {print $2}' /etc/datadog-agent/datadog.yaml)
        __secret__DD_APP_KEY=$(echo -n "${globals.__secret__vaultSecretData}" | base64 -d)

        MUTE_END=$(date -d "+${this.duration:60}min" +%s)

        curl "https://api.${DD_SITE}/api/v1/host/$DD_HOSTNAME/mute" \
          -XPOST \
          -H 'Content-Type: application/json' \
          -H "DD-API-KEY: $DATADOGAPIKEY" \
          -H "DD-APPLICATION-KEY: $__secret__DD_APP_KEY"  \
          -d "{\"end\": $MUTE_END, \"action\":\"Muted\", \"override\": \"true\"}"
        # always exit with 0 so that Jelastic does not stop there in case of problems with Datadog:
        exit 0

  unmuteDatadogHost:
    # Parameters:
    #  - target: target node group or id
    - getVaultData
    - vaultSecretReadKeyB64:
        secretPath: "paas/customers/${globals.organizationName}/common/datadog"
        secretKey: "datadog_app_key"
    - cmd[${this.target}]: |-
        DD_HOSTNAME=$(awk '$1=="hostname:" {print $2}' /etc/datadog-agent/datadog.yaml)
        __secret__DD_APP_KEY=$(echo -n "${globals.__secret__vaultSecretData}" | base64 -d)

        curl "https://api.${DD_SITE}/api/v1/host/$DD_HOSTNAME/unmute" \
          -XPOST \
          -H "DD-API-KEY: $DATADOGAPIKEY" \
          -H "DD-APPLICATION-KEY: $__secret__DD_APP_KEY"

  checkDatadogBrowserTests:
    # Parameters:
    #  - postCheck (boolean): this parameter should be true if the goal is to check browser tests
    #    after a specific operation to valid if the ones that were working prior are still working.
    #    Optional, default: false
    - if ("${this.postCheck.print()}" == ""):
        set:
          postCheck: false
    - getVaultData
    - vaultSecretReadKeyB64:
        secretPath: "paas/customers/${globals.organizationName}/common/datadog"
        secretKey: "datadog_app_key"
    - cmd [proc]: |-
        DD_HOSTNAME=$(awk '$1=="hostname:" {print $2}' /etc/datadog-agent/datadog.yaml)
        __secret__DD_APP_KEY=$(echo -n "${globals.__secret__vaultSecretData}" | base64 -d)
        file=/opt/tomcat/temp/browser_tests
        # post_check should be true if we check browser tests after a specific operation
        # to valid if the ones that were working are still working
        post_check=${this.postCheck}

        # If it is the initial check, we fetch the list of browser tests first
        if ! $post_check; then
          rm -f $file
          resp=$(curl "https://api.${DD_SITE}/api/v1/synthetics/tests" \
                      -fsS \
                      -H "DD-API-KEY: $DATADOGAPIKEY" \
                      -H "DD-APPLICATION-KEY: $__secret__DD_APP_KEY") || exit 1
          $(echo $resp | jq -r 'has("tests")') || exit 2
          tests=($(echo $resp | jq -r '[.tests[] | select(.type == "browser") | .public_id] | join(" ")'))
        else # Otherwise we get the list from the file generated during the initial check
          [ -f $file ] && tests=($(cat $file))
        fi

        # Nothing to do if there is no browser test (or working browser test in case of post-check)
        if [ -z $tests ]; then
          echo "No browser test was found, nothing to do."
          exit 0
        fi

        # Then we trigger each browser test from the list and store the result_id to check it later
        declare -A result_ids
        for test_id in ${tests[@]}; do
          resp=$(curl "https://api.${DD_SITE}/api/v1/synthetics/tests/trigger" \
                      -fsS -XPOST \
                      -H "Accept: application/json" \
                      -H "Content-Type: application/json" \
                      -H "DD-API-KEY: $DATADOGAPIKEY" \
                      -H "DD-APPLICATION-KEY: $__secret__DD_APP_KEY" \
                      -d '{"tests": [{"public_id": "'$test_id'"}]}') || exit 3
          $(echo $resp | jq -r 'has("results")') || exit 4
          result_ids["$test_id"]="$(echo $resp | jq -r '.results[0].result_id')"
        done

        # For each test we check the result using the corresponding result_id
        for test_id in ${tests[@]}; do
          timeout=300
          until [ $timeout -le 0 ]; do
            echo "Fetching result #${result_ids[$test_id]} for browser test #${test_id}..."
            resp=$(curl "https://api.${DD_SITE}/api/v1/synthetics/tests/browser/${test_id}/results/${result_ids[$test_id]}" \
                        -fs \
                        -H "DD-API-KEY: $DATADOGAPIKEY" \
                        -H "DD-APPLICATION-KEY: $__secret__DD_APP_KEY")
            if [ "$(echo $resp | jq -r '.result.eventType')" = "finished" ]; then
              passed=$(echo $resp | jq -r '.result.passed')
              break
            fi
            sleep 10
            ((timeout-=10))
          done
          if [ $timeout -le 0 ]; then
            echo "Timeout when trying to get result #${result_ids[$test_id]} for browser test #$test_id, please check."
            exit 5
          fi
          if ! $post_check && $passed; then
            echo "$test_id" >> $file
          elif $post_check && ! $passed; then
            echo "Browser test #$test_id does not work anymore (result #${result_ids[$test_id]}), please check."
            exit 6
          fi
        done

  getPapiInfoAll:
    - getVaultData
    - vaultSecretReadKeyB64:
        secretPath: "paas/customers/${globals.organizationName}/paas_${env.envName}/papi"
        secretKey: "token"
    - setGlobals:
        __secret__papiToken: '${globals.__secret__vaultSecretData.fromBase64()}'
    - getPapiData

  updateEnvStatusInPapi:
    # Parameters:
    #  - status: stopped, running, creating
    - if ("HideThisLine" && "${globals.__secret__papiToken.print()}" == ""):
        getPapiInfoAll
    - cmd[${nodes.cp.first.id}]: |-
        __secret__PAPI_TOKEN="${globals.__secret__papiToken}"
        export PAPI_TOKEN="$__secret__PAPI_TOKEN"
        export PAPI_HOSTNAME="${globals.papiHostname}"
        export PAPI_ENV_ID="${globals.papiEnvId}"
        export PAPI_API_VERSION="${globals.papiApiVersion}"
        papi.py -X PUT -d '{"status": "${this.status}"}' paas-environment/$PAPI_ENV_ID


  updateProductVersionInPapi:
    # Parameters:
    #  - product: dx, unomi
    #  - version: product verion
    - if ("HideThisLine" && "${globals.__secret__papiToken.print()}" == ""):
        getPapiInfoAll
    - cmd[${nodes.cp.first.id}]: |-
        __secret__PAPI_TOKEN="${globals.__secret__papiToken}"
        export PAPI_TOKEN="$__secret__PAPI_TOKEN"
        export PAPI_HOSTNAME="${globals.papiHostname}"
        export PAPI_ENV_ID="${globals.papiEnvId}"
        export PAPI_API_VERSION="${globals.papiApiVersion}"
        version=$(echo "${this.product}_${this.version}" | tr -s '.' '-')
        papi.py -X PUT -d "{\"paas_product_version_id\": \"$version\"}" paas-environment/$PAPI_ENV_ID

  setEnvironmentAppId:
    - if ("HideThisLine" && "${globals.__secret__papiToken.print()}" == ""):
        getPapiInfoAll
    - cmd[${nodes.cp.first.id}]: |-
        __secret__PAPI_TOKEN="${globals.__secret__papiToken}"
        export PAPI_TOKEN="$__secret__PAPI_TOKEN"
        export PAPI_HOSTNAME="${globals.papiHostname}"
        export PAPI_ENV_ID="${globals.papiEnvId}"
        export PAPI_API_VERSION="${globals.papiApiVersion}"
        papi.py -X PUT -d '{"jelastic_appid": "${env.appid}"}' paas-environment/$PAPI_ENV_ID

  deleteEnvironment:
    - if ("HideThisLine" && "${globals.__secret__papiToken.print()}" == ""):
        getPapiInfoAll
    - script: |
        import org.apache.http.client.methods.HttpGet;
        import org.apache.http.impl.client.HttpClients;
        import org.apache.http.util.EntityUtils;
        __secret__papiToken = "${globals.__secret__papiToken}";
        getPaasEnv = new HttpGet("https://${globals.papiHostname}/api/${globals.papiApiVersion}/paas-environment/${globals.papiEnvId}");
        getPaasEnv.setHeader("X-PAPI-KEY", __secret__papiToken);
        httpClient = HttpClients.createDefault();
        resp = httpClient.execute(getPaasEnv);
        if (resp.getStatusLine().getStatusCode() != 200) {
          return {"result": 1, errOut: "Can't get paas environment " + "${globals.papiEnvId}" };
        }
        paasEnv = JSON.parse(EntityUtils.toString(resp.getEntity()));
        papierId = paasEnv["papier_id"]
        return {'result': 0, 'papierId': papierId };
    - setGlobals:
        papierId: ${response.papierId}
    - script: |
        import org.apache.http.client.methods.HttpDelete;
        import org.apache.http.impl.client.HttpClients;
        import org.apache.http.util.EntityUtils;
        __secret__papiToken = "${globals.__secret__papiToken}";
        paasEnvDelete = new HttpDelete("https://${globals.papiHostname}/api/${globals.papiApiVersion}/paas-environment/${globals.papiEnvId}");
        paasEnvDelete.setHeader("X-PAPI-KEY", __secret__papiToken);
        httpClient = HttpClients.createDefault();
        resp = httpClient.execute(paasEnvDelete);
        if (resp.getStatusLine().getStatusCode() != 204) {
          return {"result": 1, errOut: "Can't delete paas environment " + "${globals.papiEnvId}" };
        }
        papierDelete = new HttpDelete("https://${globals.papiHostname}/api/${globals.papiApiVersion}/papier/${globals.papierId}");
        papierDelete.setHeader("X-PAPI-KEY", __secret__papiToken);
        resp1 = httpClient.execute(papierDelete);
        if (resp1.getStatusLine().getStatusCode() != 204) {
          return {"result": 1, errOut: "Can't delete papier " + "${globals.papierId}" };
        }
        return {'result': 0, 'out': "Paas Environment - ${globals.papiEnvId} and Papier - ${globals.papierId} has been deleted" };

  addEnvMetadataToNodeGroup:
    - cmd[cp]: echo "${user.email}" | cut -d'@' -f1
    - set:
        organizationName: ${response.out}
    - script: |-
        orgName = "${this.organizationName}";
        __secret__vaultRoleId = "${this.__secret__vaultRoleId}";
        __secret__vaultSecretId = "${this.__secret__vaultSecretId}";
        vaultClusterUrl = "${this.vaultClusterUrl}";
        papiHostname = "${this.papiHostname}";
        papiApiVersion = "${this.papiApiVersion}";
        papiEnvId = "${this.papiEnvId}";

        return jelastic.env.control.ApplyNodeGroupData(
          '${env.envName}',
          session,
          nodeGroup='cp',
          data={"ORGANIZATION_NAME": orgName,
                "VAULT_ROLE_ID": __secret__vaultRoleId,
                "VAULT_SECRET_ID": __secret__vaultSecretId,
                "VAULT_CLUSTER_URL": vaultClusterUrl,
                "PAPI_HOSTNAME": papiHostname,
                "PAPI_API_VERSION": papiApiVersion,
                "PAPI_ENV_ID": papiEnvId
              }
        );

  setJelEnvRoleInNodeGroupData:
    - cmd[${nodes.cp.first.id}]: |-
        source /metadata_from_HOST
        if [ -z $JEL_ENV_ROLE ]; then
          echo "JEL_ENV_ROLE variable is not defined in /metadata_from_HOST"
          exit 1
        fi
        echo $JEL_ENV_ROLE

    - environment.nodegroup.ApplyData [cp]:
        data:
          JEL_ENV_ROLE: ${response.out}

  getVaultData:
    - script: |
        const envName = "${env.envName}";
        orgName = jelastic.env.control.GetNodeGroups(envName, session).object.filter(function (object) {
                                        return object.name == "cp";}).pop().ORGANIZATION_NAME;
        vaultUrl = jelastic.env.control.GetNodeGroups(envName, session).object.filter(function (object) {
                                        return object.name == "cp";}).pop().VAULT_CLUSTER_URL;
        roleId = jelastic.env.control.GetNodeGroups(envName, session).object.filter(function (object) {
                                        return object.name == "cp";}).pop().VAULT_ROLE_ID;
        secretId = jelastic.env.control.GetNodeGroups(envName, session).object.filter(function (object) {
                                        return object.name == "cp";}).pop().VAULT_SECRET_ID;
        return {
          "result": 0,
          "onAfterReturn": {
            setGlobals: {
              "organizationName": orgName,
              "vaultClusterUrl": vaultUrl,
              "__secret__vaultRoleId": roleId,
              "__secret__vaultSecretId": secretId
            }
          }
        };

  getPapiData:
    - script: |
        const envName = "${env.envName}";
        papiEnvId = jelastic.env.control.GetNodeGroups(envName, session).object.filter(function (object) {
                                        return object.name == "cp";}).pop().PAPI_ENV_ID;
        papiHostname = jelastic.env.control.GetNodeGroups(envName, session).object.filter(function (object) {
                                        return object.name == "cp";}).pop().PAPI_HOSTNAME;
        papiApiVersion = jelastic.env.control.GetNodeGroups(envName, session).object.filter(function (object) {
                                        return object.name == "cp";}).pop().PAPI_API_VERSION;
        return {
          'result': 0,
          'papi_env_id': papiEnvId,
          'papi_hostname': papiHostname,
          'papi_api_version': papiApiVersion
        };
    - setGlobals:
        papiApiVersion: ${response.papi_api_version}
        papiEnvId: ${response.papi_env_id}
        papiHostname: ${response.papi_hostname}

  getEnvStatus:
    # Parameters:
    #   - envName: Env name of linked jahia or jcustomer
    - script: |
        resp = jelastic.env.control.GetEnvInfo('${this.envName}', session);
        return {"result": 0, "out": resp.env.status};

  muteDatadogSynthetics:
    # Parameters:
    #  - duration: mute duration in minutes. Optional, default 60
    - getVaultData
    - vaultSecretReadKeyB64:
        secretPath: "paas/customers/${globals.organizationName}/common/datadog"
        secretKey: "datadog_app_key"
    - cmd[${nodes.cp.first.id}]: |-
        __secret__DD_APP_KEY=$(echo -n "${globals.__secret__vaultSecretData}" | base64 -d)
        DD_SYNTHETICS_TEST=https://api.${DD_SITE}/api/v1/synthetics/tests
        MUTE_END=$(date -d "+${this.duration:60}min" +%s)
        monitor_id=$(curl -s $DD_SYNTHETICS_TEST \
                      -H 'Content-Type: application/json' \
                      -H "DD-API-KEY: $DATADOGAPIKEY" \
                      -H "DD-APPLICATION-KEY: $__secret__DD_APP_KEY" \
                      | jq -er '.tests[] | select(.config.request.url | contains("https://${env.shortdomain}.")) | .monitor_id')
        if [[ $? -ne 0 ]]; then
          echo "[INFO] No synthetics defined for ${env.envName}"
          exit 0
        fi
        DD_MONITOR_SEARCH=https://api.${DD_SITE}/api/v1/monitor/search?query=synthetics
        monitor_mute_status=$(curl -s $DD_MONITOR_SEARCH \
                             -H 'Content-Type: application/json' \
                             -H "DD-API-KEY: $DATADOGAPIKEY" \
                             -H "DD-APPLICATION-KEY: $__secret__DD_APP_KEY" \
                             | jq -er '.monitors[] | select(.id | contains('$monitor_id')) | .muted_until_ts')
        if [ $monitor_mute_status != null ]; then
          echo "[INFO] Synthetics is already muted. Nothing to do."
          exit 0
        fi
        curl -s "https://api.${DD_SITE}/api/v1/monitor/$monitor_id/mute" \
          -XPOST \
          -H 'Content-Type: application/json' \
          -H "DD-API-KEY: $DATADOGAPIKEY" \
          -H "DD-APPLICATION-KEY: $__secret__DD_APP_KEY" \
          -d "{\"end\": $MUTE_END}"

  unmuteDatadogSynthetics:
    - getVaultData
    - vaultSecretReadKeyB64:
        secretPath: "paas/customers/${globals.organizationName}/common/datadog"
        secretKey: "datadog_app_key"
    - cmd[${nodes.cp.first.id}]: |-
        __secret__DD_APP_KEY=$(echo -n "${globals.__secret__vaultSecretData}" | base64 -d)
        DD_SYNTHETICS_TEST=https://api.${DD_SITE}/api/v1/synthetics/tests
        monitor_id=$(curl -s $DD_SYNTHETICS_TEST \
                    -H 'Content-Type: application/json' \
                    -H "DD-API-KEY: $DATADOGAPIKEY" \
                    -H "DD-APPLICATION-KEY: $__secret__DD_APP_KEY" \
                    | jq -er '.tests[] | select(.config.request.url | contains("https://${env.shortdomain}.")) | .monitor_id')
        if [[ $? -ne 0 ]]; then
          echo "[INFO] No synthetics defined for ${env.envName}"
          exit 0
        fi
        DD_MONITOR_SEARCH=https://api.${DD_SITE}/api/v1/monitor/search?query=synthetics
        monitor_mute_status=$(curl -s $DD_MONITOR_SEARCH \
                             -H 'Content-Type: application/json' \
                             -H "DD-API-KEY: $DATADOGAPIKEY" \
                             -H "DD-APPLICATION-KEY: $__secret__DD_APP_KEY" \
                             | jq -er '.monitors[] | select(.id | contains('$monitor_id')) | .muted_until_ts')
        if [ $monitor_mute_status == null ]; then
          echo "[INFO] Synthetics is already unmuted. Nothing to do."
          exit 0
        fi
        # Iterating over the monitor status and unmute it once monitor status is 'OK'
        # Once max iterations(~5mins for 180 iterations) is reached, we unmute the monitor regardless of the status.
        for (( i=1; i<=180; i++ )); do
          monitor_status=$(curl -s $DD_MONITOR_SEARCH \
                          -H 'Content-Type: application/json' \
                          -H "DD-API-KEY: $DATADOGAPIKEY" \
                          -H "DD-APPLICATION-KEY: $__secret__DD_APP_KEY" \
                          | jq -er '.monitors[] | select(.id | contains('$monitor_id')) | .status')
          if [[ "$monitor_status" == "OK" ]]; then
            break
          fi
          sleep 1
        done
        curl -s "https://api.${DD_SITE}/api/v1/monitor/$monitor_id/unmute" \
          -XPOST \
          -H 'Content-Type: application/json' \
          -H "DD-API-KEY: $DATADOGAPIKEY" \
          -H "DD-APPLICATION-KEY: $__secret__DD_APP_KEY"

  muteEnvWideMonitors:
    # Parameters:
    #  - duration: mute duration in minutes. Optional, default 2880 (48h)
    muteMonitorsByTags:
      duration: ${this.duration:2880}
      tag: env-wide

  unmuteEnvWideMonitors:
    unmuteMonitorsByTags:
      tag: env-wide

  muteMonitorsImpactedByOtherNodes:
    muteMonitorsByTags:
      duration: ${this.duration:2880}
      tag: impacted-by-other-nodes

  unmuteMonitorsImpactedByOtherNodes:
    unmuteMonitorsByTags:
      tag: impacted-by-other-nodes

  muteMonitorsByTags:
    # Parameters:
    #  - duration: mute duration in minutes. Optional, default 2880 (48h)
    #  - tag: the tag of monitors to mute
    - getVaultData
    - vaultSecretReadKeyB64:
        secretPath: "paas/customers/${globals.organizationName}/common/datadog"
        secretKey: "datadog_app_key"
    - cmd[${nodes.cp.first.id}]: |-
        __secret__DD_APP_KEY=$(echo -n "${globals.__secret__vaultSecretData}" | base64 -d)
        SCOPE_TAG="${this.tag}"
        monitors_id=($(curl -s "https://api.${DD_SITE}/api/v1/monitor/search?query=tag%3A%22$SCOPE_TAG%22" -H "DD-APPLICATION-KEY: $__secret__DD_APP_KEY" -H "DD-API-KEY: $DATADOGAPIKEY" | jq '.monitors[] | .id'))
        MUTE_END=$(date -d "+${this.duration:2880}min" +%s)

        ENVNAME="${env.envName}"
        for monitor_id in "${monitors_id[@]}"; do
          curl -s "https://api.${DD_SITE}/api/v1/monitor/$monitor_id/mute?scope=envname:$ENVNAME&end=$MUTE_END" -H "DD-APPLICATION-KEY: $__secret__DD_APP_KEY" -H "DD-API-KEY: $DATADOGAPIKEY" -XPOST
        done

  unmuteMonitorsByTags:
    # Parameters:
    #  - tag: the tag of monitors to unmute
    - getVaultData
    - vaultSecretReadKeyB64:
        secretPath: "paas/customers/${globals.organizationName}/common/datadog"
        secretKey: "datadog_app_key"
    - cmd[${nodes.cp.first.id}]: |-
        __secret__DD_APP_KEY=$(echo -n "${globals.__secret__vaultSecretData}" | base64 -d)
        SCOPE_TAG="${this.tag}"
        monitors_id=($(curl -s "https://api.${DD_SITE}/api/v1/monitor/search?query=tag%3A%22$SCOPE_TAG%22" -H "DD-APPLICATION-KEY: $__secret__DD_APP_KEY" -H "DD-API-KEY: $DATADOGAPIKEY" | jq '.monitors[] | .id'))

        ENVNAME="${env.envName}"
        for monitor_id in "${monitors_id[@]}"; do
          curl -s "https://api.${DD_SITE}/api/v1/monitor/$monitor_id/unmute?scope=envname:$ENVNAME" -H "DD-APPLICATION-KEY: $__secret__DD_APP_KEY" -H "DD-API-KEY: $DATADOGAPIKEY" -XPOST
        done

  setupRclone:
    # Parameters
    # target: (optional) the node/nodeGroup to setup
    - setGlobalRepoRootUrl
    - fetchS3LogsBucketInfos
    - setS3LogsBucketName:
        s3LogsBucketName: ${globals.__secret__bucket_name}
    - fetchRcloneFiles:
        target: ${this.target:*}
    - setupLogsRCloneConfig:
        provider: ${globals.logs_bucket_provider}
        region: ${globals.s3_bucket_region}
        __secret__access_key: ${globals.__secret__access_key}
        __secret__secret_key: ${globals.__secret__secret_key}
        __secret__aes256_key: ${globals.__secret__aes256_key}
        target: ${this.target:*}


  fetchRcloneFiles:
    # Parameters
    # target: (optional) the node/nodeGroup to setup
    - cmd[${this.target:*}]: |-
        curl --retry 6 -fSsLo /etc/cron.d/rclone-cron ${globals.repoRootUrl}/assets/common/rclone-cron
        curl --retry 6 -fSsLo /usr/local/bin/rclone-logs.sh ${globals.repoRootUrl}/assets/common/rclone-logs.sh
        chmod +x /usr/local/bin/rclone-logs.sh
        rclone_dir=/root/.config/rclone
        rclone_conf=$rclone_dir/rclone.conf
        if [ ! -f $rclone_conf ]; then
          mkdir -p $rclone_dir
          curl --retry 6 -fSsLo $rclone_conf ${globals.repoRootUrl}/assets/common/rclone.conf
        fi

  setupLogsRCloneConfig:
    # Parameters
    #   - Mandatory:
    #     - provider: the cloud provider hosting the s3 bucket
    #     - region: the region of the s3 bucket
    #     - __secret__access_key: the access key used by rclone
    #     - __secret__secret_key: the secret key used by rclone
    #   - Optional:
    #     - __secret__aes256_key: the aes256 key used by rclone to encrypt/decrypt data when region is OVH
    #     - target: the node/nodeGroup to execute commands on
    - cmd[${this.target:*}]: |-
        rclone_conf=/root/.config/rclone/rclone.conf
        provider="${this.provider}"
        region="${this.region}"
        __secret__access_key="${this.__secret__access_key}"
        __secret__secret_key="${this.__secret__secret_key}"
        __secret__aes256_key="${this.__secret__aes256_key.print()}"

        set -e
        sed -e "s/LOGS_REGION_PLACEHOLDER/$region/" \
            -e "s/LOGS_ACCESS_KEY_PLACEHOLDER/$__secret__access_key/" \
            -e "s#LOGS_SECRET_KEY_PLACEHOLDER#$__secret__secret_key#" \
            -i $rclone_conf

        if [ "$provider" = "ovh" ]; then
          provider="Other"
          endpoint="https://s3.$region.io.cloud.ovh.net/"
          sed -e "s;LOGS_ENDPOINT_PLACEHOLDER;$endpoint;" \
              -e "s#LOGS_AES256_KEY_PLACEHOLDER#$__secret__aes256_key#" \
              -e "/#PROVIDER_AWS/d" \
              -e "s/ #PROVIDER_OVH//" \
              -i $rclone_conf
        else
          provider=AWS
          sed -e "s/ #PROVIDER_AWS//" \
              -e "/#PROVIDER_OVH/d" \
              -i $rclone_conf
        fi
        sed -i "s/LOGS_PROVIDER_PLACEHOLDER/$provider/" $rclone_conf
        echo $rclone_conf >> /etc/jelastic/redeploy.conf

  # Similarly to what has been done for setupBackupRCloneConfig, we force the OVH
  # region to be GRA
  fetchS3LogsBucketInfos:
    # Parameters:
    #   - target
    # Fetch s3 logs bucket info from papi and store them in nodes env vars
    - if ("HideThisLine" && "${globals.__secret__papiToken.print()}" == ""):
        getPapiInfoAll
    - cmd[${nodes.cp.first.id}]: |-
        set -e
        __secret__PAPI_TOKEN="${globals.__secret__papiToken}"
        export PAPI_TOKEN="$__secret__PAPI_TOKEN"
        export PAPI_HOSTNAME="${globals.papiHostname}"
        export PAPI_ENV_ID="${globals.papiEnvId}"
        export PAPI_API_VERSION="${globals.papiApiVersion}"
        organization_id=$(papi.py -X GET paas-environment/$PAPI_ENV_ID | jq -r '.paas_organization_id')
        organization=$(papi.py -X GET paas-organization/$organization_id)
        bucket_name=$(echo $organization | jq -r '.logs_s3_bucket')
        region_id=$(echo $organization | jq -r '.logs_s3_bucket_region_id')
        region=$(papi.py -X GET paas-region/$region_id)
        provider=$(echo $region | jq -r .provider)
        if [ "$provider" = "ovh" ]; then
          region_code=gra
        else
          region_code=$(echo $region | jq -r .code)
        fi
        credentials=$(papi.py -X GET paas-organization/$organization_id/secret)
        secret_key=$(echo $credentials | jq -r '.secret_key')
        access_key=$(echo $credentials | jq -r '.secret_access_key')
        aes256_key=$(echo $credentials | jq -r '.aes256_key')

        echo """
        {
          \"__secret__bucket_name\": \"$bucket_name\",
          \"__secret__access_key\": \"$access_key\",
          \"__secret__secret_key\": \"$secret_key\",
          \"__secret__aes256_key\": \"$aes256_key\",
          \"s3_bucket_region\": \"$region_code\",
          \"logs_bucket_provider\": \"$provider\"
        }
        """
    - script: |-
        valid_groups = ["cp", "proc", "bl"];
        const __secret__data = ${response.out.toJSON()};
        return {"result": 0, "onAfterReturn": {setGlobals: __secret__data}}

  setS3LogsBucketName:
    # Params:
    #   s3LogsBucketName
    - script: |-
        valid_groups = ["cp", "proc", "bl"];
        jelastic.environment.control.getnodegroups("${env.envName}", session)["object"].forEach((nodeGroup) => {
          if ( valid_groups.includes(nodeGroup.name) ) {
            jelastic.env.control.AddContainerEnvVars(
              '${env.envName}',
              session,
              nodeGroup=nodeGroup.name,
              vars={
                "logs_s3_bucket_name": "${this.s3LogsBucketName}",
              }
            );
          }
        });

        return {"result": 0}

  updateS3LogsCredentials:
    - fetchS3LogsBucketInfos
    - cmd[*]: |-
        rclone_conf=/root/.config/rclone/rclone.conf
        provider="${globals.logs_bucket_provider}"
        region="${globals.s3_bucket_region}"
        __secret__access_key="${globals.__secret__access_key}"
        __secret__secret_key="${globals.__secret__secret_key}"
        __secret__aes256_key="${globals.__secret__aes256_key.print()}"

        set -e
        sed -e "s/access_key_id.*/access_key_id = $__secret__access_key/" \
            -e "s#secret_access_key.*#secret_access_key = $__secret__secret_key#" \
            -i $rclone_conf

        if [ "$provider" = "ovh" ]; then
          sed -e "s/sse_customer_key.*/sse_customer_key = $__secret__aes256_key/" -i $rclone_conf
        fi

  getEnvCloudProvider:
    # Returns
    #  provider: the CloudProvider hosting the env
    - cmd[${nodes.cp.first.id}]: |-
        awk -F'=' '$1=="JEL_CLOUDPROVIDER" {print $2}' /metadata_from_HOST
    - setGlobals:
       provider: ${response.out}

  getEnvRegion:
    # Returns
    #  region: the region hosting the env
    - cmd[${nodes.cp.first.id}]: |-
        awk -F'=' '$1=="JEL_REGION" {print $2}' /metadata_from_HOST
    - setGlobals:
        region: ${response.out}

  getEnvRole:
    # Returns
    #  envRole: the cluster role hosting the environment (dev/preprod/prod)
    - cmd[${nodes.cp.first.id}]: |-
        awk -F'=' '$1=="JEL_ENV_ROLE" {print $2}' /metadata_from_HOST
    - setGlobals:
       envRole: ${response.out}

  isNodeRunning:
    # Checks if a node is running, meaning the whole CT, not just the service (for example tomcat or haproxy)
    #
    # Parameters:
    # - nodeId
    # - envName (optional, default: the current env)
    # - globalVarName (optional, default: "isNodeRunning")
    #
    # Returns:
    # - provider: the CloudProvider hosting the env
    - if ("${this.globalVarName.print()}" == ""):
        set:
          globalVarName: isNodeRunning
    - script: |-
        var nodeId = ${this.nodeId}
        if ("${this.envName.print()}" == "") {
          var envName = "${env.envName}"
        } else {
          var envName = "${this.envName}"
        }
        if ("${this.globalVarName.print()}" == "") {
          var globalVarName = "isNodeRunning"
        } else {
          var globalVarName = "${this.globalVarName}"
        }
        var resp = jelastic.env.control.GetEnvInfo(envName, session)
        if (! resp.hasOwnProperty("nodes")) {
          return {"result": 1, "error": "The GetEnvInfo API call failed, please check", "response": resp}
        }
        var isNodeRunning = true
        var nodeFound = false
        resp.nodes.forEach(
          function (node) {
            if (node.id == parseInt(nodeId)) {
              nodeFound = true
              if (node.status != 1) {
                isNodeRunning = false
              }
            }
          }
        )
        if (! nodeFound) {
          return {"result": 1, "error": "Node " + nodeId + " was not found for " + envName + " environment, please check"}
        }
        res = {"result": 0}
        res.onAfterReturn = {
          setGlobals: {
            ${this.globalVarName}: isNodeRunning
          }
        }
        return res

  checkEnvProvides:
    # Checks if the cp's _PROVIDE envvar match the action's placeholder
    - script: |-
        resp = jelastic.env.control.GetContainerEnvVarsByGroup('${env.envName}', session, nodegroup='cp')
        if(resp.object._PROVIDE == "${this}") {
          result = 0
          msg = "${env.envName} provides a " + resp.object._PROVIDE
          }
        else {
          result = 666
          msg = "${env.envName} doesn't provides a ${this} but a " + resp.object._PROVIDE
          }
        return {"result": result, "msg": msg}

  checkExternalDomains:
    # Parameters:
    #  outputFilePath: the file path to store results
    - api: environment.binder.GetExtDomains
    - cmd[${nodes.cp.first.id}]: |-
        out=${this.outputFilePath}
        if [ ! -d $(dirname $out) ]; then
          mkdir -p $(dirname $out)
        fi
        echo -n "" > $out
        response='${response.extDomains}'
        domains=$(echo $response | jq | grep domain | sed 's/.*: "\(.*\)",/\1/')
        if [ "$domains" != "" ]; then
          while IFS= read -r domain; do
            # First, we try to request the domain
            response_code=$(curl -fLsSo /dev/null -w "%{http_code}" https://$domain)
            res=$?
            if [ $res -ne 0 ] || [ "$response_code" != "200" ]; then
              # If previous attempt failed, we try by requesting jahia directly with domain in Host header
              response_code=$(curl -fLsSo /dev/null -w "%{http_code}" 127.0.0.1 -H "Host: $domain")
              res=$?
            fi
            if [ $res -ne 0 ] || [ "$response_code" != "200" ]; then
              echo "$domain NOK ($response_code)" >> $out
            else
              echo "$domain OK" >> $out
            fi
          done<<<$(echo "$domains")
        fi

  checkExternalDomainsAfterMigration:
    # Parameters:
    #  outputFilePath: the file path to store results
    - checkExternalDomains:
        outputFilePath: ${this.outputFilePath}
    - cmd[${nodes.cp.first.id}]: |-
        diff=$(diff /var/tmp/cloud/domains_check/afterMigrateToV${globals.version} /var/tmp/cloud/domains_check/beforeMigrateToV${globals.version})
        if [ "$diff" != "" ]; then
          domains=$(echo "$diff" | grep -e "^<" -e "^>" | awk '{print $2}' | sort | uniq | sed -z -e 's/\n/, /g' -e 's/, $//')
          timestamp=$(date +"%Y-%m-%dT%H:%M:%S")
          echo "$timestamp - Domains check result has changed for the following domains: $domains" >> /var/log/jelastic-packages/domainscheck.log
        fi
